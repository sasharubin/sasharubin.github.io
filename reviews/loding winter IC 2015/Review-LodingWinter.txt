----------------------------------------------------------------------------------------------------
1. Title of the paper and authors
----------------------------------------------------------------------------------------------------

Synthesis of deterministic top-down tree transducers from automatic tree
relations, Christof L\"oding and Sarah Winter

----------------------------------------------------------------------------------------------------
2. Significance
----------------------------------------------------------------------------------------------------

The topic of synthesis of automatic relations is very relevant to the readers of
this journal.  However, the authors should do much more to justify the focus on
finite trees.

----------------------------------------------------------------------------------------------------
3. Technical content
----------------------------------------------------------------------------------------------------

This paper studies the realizability and synthesis problems for specifications
given by regular binary relations of finite trees, and implementations given by
deterministic top-down tree transducers. The paper considers various classes of
specifications C (e.g., deterministic top-down tree automata, and
nondeterministic top-down tree automata) and implementations F (e.g.,
deterministic top-down tree transducers with delay k, and with arbitrary delay).
The theorems are all of the following form: ``it is decidable given a
specification from C if it can be realized by an implementation from F". There
is no discussion of the computational complexity of the decision procedures.

The motivation for studying synthesis is clear, and its importance was already
noted by Church [1] in the 50s or 60s. However, the motivation for studying
synthesis of regular specifications over finite trees in particular is less
clear. The authors give one seemingly useful citation, i.e., typechecking XML
transformers [7], but do not elaborate. Moreover, their particular
choices of F and C are not justified.

The proof techniques for deterministic specifications are heavily based on [5]
which solves similar problems but for finite words (instead of finite trees).
These techniques come from the theory of graphs, i.e., games on graphs (e.g.,
safety games are positionally determined) and some Ramsey theory on graphs.

The proof techniques for non-deterministic specifications again use games, and 
also automata theory. One of the proofs (Theorem 18) seems closely related to
[10], although the authors do not say how close.

Although the theorems are novel, and probably correct, there seem to be some
problems in the proofs (see comments to authors).

----------------------------------------------------------------------------------------------------
4. Presentation
-----------------------------------------------------------------------------------------------------

The title and abstract are clear, and the overall structure of the article is
good.

However, there are many typos and much unclear writing in the definitions (see
comments to authors).

Some references have missing information and the formatting is inconsistent (see
comments to authors).

Although enough related work is cited, the exact relationship to this work is
not well explained and should be more detailed (see comments to authors).  For
instance, many of the proofs are variations of the case for words. The authors
would do the reader a service by explaining the differences between the two
cases (in one case they do).

As a point of reference, the style and presentation of [5] is excellent and
clear, and thus worth aiming for.

----------------------------------------------------------------------------------------------------
5. Overall recommendation
----------------------------------------------------------------------------------------------------

I suggest to accept with major revisions.

----------------------------------------------------------------------------------------------------
6. Comments to the authors
----------------------------------------------------------------------------------------------------

General comments

- The motivation for the current work is not sufficiently detailed. Is there a
  relevant example from, say, [7] (typechecking XML transformations)?

Solving synthesis by (deterministic) tree transducers without delay follows
standard game-theoretic literature. One of the main advantages of this work is
that it considers implementations by transducers with delay. Delay has been
considered in the case of words [4]. Please say why tree-transducers with delay
are worth studying.

Also, tree transducers are not as well known as word transducers. Please discuss 
these objects in more detail, perhaps a brief introduction to what they can do
and how they are used is appropriate.

- It only makes sense to study the uniformization decision problem for C and F
  if, e.g., it is not the case that every relation from C has a uniformizer in
F. This issue should be discussed.

- A certain construct starting with "As ..." appears a few times, and should be
  rephrased.  I.e., "As the class of regular word languages, the class of
regular tree languages is closed under Boolean operations." should be written,
e.g. "Just as the class of regular word languages is closed under Boolean
operations, so too is the class of regular tree languages".

- Please highlight all terms when they are defined for the first time.

- The notation for automata and transducers could be made more uniform, e.g.,
  since all automata are top-down in this paper, perhaps you can dispense with
the arrow in the notation?

- The phrase "transducers of bounded delay" is ambiguous. 

For integer k, let T_k := all transducers with delay at most k. Then the phrase
"transducers of bounded delay" could mean \cup_k T_k, or it could mean the class
T_k for some fixed k. Indeed, the Abstract states "we provide decision
procedures for ... bounded ...  delay" which suggests you mean that there is an
algorithm that solves uniformization for the class \cup_k T_k, but actually the
proof of Theorem 3 implies that there is an algorithm that given k solves
uniformization for the class T_k.  Please make the phrasing clearer (although
this is hard to do in a short abstract, it should be made clearer in the body of
the document).

- The phrase "transducer of unbounded delay" is used incorrectly. The phrase
  means that the transducer is not in \cup_k T_k. However, it is used to mean
that the transducer need not have bounded delay, i.e., there is no restriction
on the delay of the transducer.

Major issue

- I have a problem with the proof of Theorem 3 (which forms the basis for other
  Theorems in this paper).  In particular, you build a game between IN and OUT.
The idea should be that IN chooses a path (input labels and input directions),
while OUT chooses output labels. However, in your construction, IN chooses input
directions in(ii) but OUT chooses input directions in(v). The problem is that if 
you give OUT the ability to choose input directions then a winning strategy for OUT 
might not uniformize every input tree.


Detailed comments

page 1

Abstract:
say what you mean by "valid input trees" (note, this is called "input
validation" in the introduction)

par 1: 
- "1957" needs a citation
- "A related notion". How is it related? Is it not the same notion? 
par 3: 
- "Such relations". Which relations? It sounds like you refer to the specs from
  the Buchi-Landweber result,
but these are over infinite words.

page 2

par 2: 
- as tool --> as a tool
- explain the meaning of "regular lookahead".
- model --> specification language (?)

par -1: 
- the definition of substring needs cleaning up, i.e., quantify v correctly.
- i suspect you mean that each letter f \in \Sigma has a single arity, not a set
  of arities. if not, this causes some strangeness in the definition of run.

page 3
par 2:
- corresponds to a rank --> is a rank of
par 3:
- the definition of concatenation needs cleaning up, i.e., i think you mean that
  t must be special, and s may be special.
- place "u" in math font in third last line.
par 4:
- linar --> linear (right? also on page 4)
par 5:
- is n = 0 allowed in the definition of T_Sigma(X_n)? this seems to be needed
  for the definition of transducer
- an 1-context --> a 1-context
par 7:
- line 1: i=1 --> i=0
par -2:
- the rank of convoluted symbols should be defined independently of u,t, etc.

page 4
par 2:
- leaf --> leaves

- in the definition of transition rules for TDTs, it would help to remind the
  reader that the x_is are variables. More importantly, please say in words how
to read the transition rules.
- in the paragraph starting "Let c_1 =", please stress (e.g., say in words) that
  the input trees are equal in the two configurations.
- i found the formal definition of successor relation very hard to parse. please
  rewrite it with better spacing/bulleting and punctuation. also please say in
words what it is doing (as you do for some other definitions). also, the fourth
line of the definition does not make sense as written (starting "\phi_2 with").
- inside the definition of R(\T), you don't need to add that t' \in T_\Gamma
  (since you already gave the domain and range of R(\T)).

par -3:
- The notation \T(t) only makes sense if \T is deterministic.

example 1:
- drawing the complete sequence would greatly help with understanding the
  definition
- the RHSs of the rules of Delta are not exactly of the required form. E.g.,
  h(q(x_1)) should be of the form w[q(x_1)] where w is a suitable 1-context.

page 5
- formally, your positional strategies are not strategies. I.e., replace "a
  positional strategy ... is ..." by "a positional strategy ... may be thought
of as ...".

par -1:
- This paragraph is confusing to me. I do not see the relationship between this
  paragraph and the lemma it is supposed to explain.


Page 6:
Lemma
- rephrase: It is decidable, given \A and q \in Q_\A, whether each of the
  following hold...

Section 3.1
- i suggest putting the definition of bounded delay into the introduction so it
  can be found easily.
- the definitions need cleaning up. I.e., "we say the configuration c has output
  delay of j at u if ...", and "the output delay of a transducer is bounded by k
if ...". Also, "reachable configuration" is not defined.

Page 7:
- please explicitly specify the domain of $path$ and $lbls$.
- the definition of T^\pi_\Sigma: I think you mean [1,i-1] instead of
  [1...(i-1)].
- i think you meant to write $f \conv g$ instead of $(f,g)$.

The definition of the game, besides the major issue mentioned above, is hard to
read. 
- in item i), "next input" --> "next input symbol" 
- in item ii), please quantify f.
- in item iii) the edge has a label ("r"), but earlier the edges of games do not
  have labels.
- in item iv): this definition is very hard to parse and should be written with
  more care. e.g., "for each $g$ such that X" but X does not mention $g$.
Also, for l \leq rk(f,g) you require that there is a single
output that is in \A_{q_l}-relation with all possible inputs. But perhaps there
does exist a uniformization, just not one of this form.

Page 8:
- In Example 4: I do not see how the automaton recognizes the language. Do you
  mean "iff" instead of "if" in the definition of R? Also, why is state "q"
needed? Aren't "q" and "q_f" enough?

Pages 10-16: 
The presentation in these pages needs a lot of attention.

As you note, the proof of the main result of this section is similar to [5].
Please state more clearly the similarities or differences between the two
proofs. Even better, you might consider recapitulating the word case and
explaining the obstacles you had to overcome to produce the tree case. 
Also, it seems that you have introduced some ideas that would simplify the word
case (e.g., they count up to 2K, you only count up to K). You should explain
why this is possible.

Also, it would be good to mention an example of a relation that can be
uniformized, but not by a transducer of bounded delay.

Page 10:
- at the start of section 3.2:
"is also decidable if the output delay is unbounded". this makes it sound like
you only consider transducers of unbounded delay. perhaps it is clearer to write
"is also decidable for the class of all transducers (i.e., there is no
restriction on the delay)".

- "In the following, we will show...". This sentence is unclear. It uses the
  word "decide" which makes me think it is talking about a decision procedure.
However, it seems it is referring to Lemma 9.

Page 11:
- The notation \rho_\A seems to depend on x, y, and i. It is probably worth stating
this explicitly, or, even better, indicating this in the notation.
- $||\T(t)||^u$: please remind the reader what this notation means, or replace
  it with a more descriptive notation. It looks like the length ||\cdot|| is
being exponentiated.
- In the definition of \tau you write "\A:q \rightarrow...". However, this
  notation is not defined. You only have defined $\A:q_0^\A \rightarrow ...". 
- In the paragraph starting "Basically, " you have a statement of the form "if
  q' = ... then XXX". However, q' does not appear in XXX. Is this just a typo?
- The term "Idempotent" usually occurs in the presence of an algebra/monoid. Is
  there a monoid here?

Page 12:
- i.e.,, (double comma)
The definition of t^n. 
- Please add a diagram. 
- Please explicitly say that you are introducing and defining s_x, s_y and
  \hat{t}. Also, it looks like s_x depends on t (and u), so it would be good if
the notation reflected (some of) these dependencies.
- The second term (s_y) is of the form (...)^n. Please say what this
  exponentiation means (presumably, concatenation).

Page 15:
- "These changes can be made because": Please disambiguate. I think you mean
  that these changes can be made effective because...
- The sentences starting "Let \T_s uniformize ..." should be rewritten; the
  if-then-else clause is hard to parse.

Page 17:
- "we have seen". Where exactly?
- "to some extent we present two approaches" is how I read this phrase.

Example 14: 
- "realize the specification"-->"implement the specification"
- why do you write f(q(x_1),q(x_1))? this seems to ensure that both
  t and t' will be equal (since q should copy t). Perhaps you meant
f(q(x_1),q'(x_1))? At any rate, it would be good to have the complete automaton.
- "either the right or the left...". Don't you mean "both the right and the
  left..."?

Theorem 15:
The intuitive explanation for the proof is very hard to understand.
- Although standard, you should explain in more detail why the proof strategy of Theorem 3 using
  games does not work for nondeterministic automata. Equally as good, perhaps
say where the proof of Theorem 3 used that the automaton was deterministic.
- The sentence "Therefore, instead of a game... we want to define a regular
  infinite tree" is also not very helpful. What does this regular infinite tree
represent?
- You say that, for theorem 15, one has to deal with the fact that the
  implementation transducer may not be linear. Why was this not a problem in
Theorem 3? 
- can be depended-->can depend
- "infinitely many different labels". What would these labels represent?
- construction for --> construction of
- "can be bounded". What can bound these?
- please remind the reader what D and n are.
- "combining all possible input sequences". You mean putting them in a set?
  Please formally define \tau_l(L).

Page 19:
- The paragraphs starting "Now that we have defined ..." and "Our goal is to
  construct a PTA..." are much clearer than the earlier explanations, and seem
to hold the main ideas of the construction. Please state these points earlier,
and merge them with the earlier explanation starting "To achieve this ... into
account".

Page 20:
- please give a formal definition of DTDT without switching.
- "to turn the uniformizer into a guide". you mean to turn the guide into a
  uniformizer?
- you cite [10] for guidable tree automata. Please explain the
  similarities/differences between [10]s use and your use of guidable tree
automata.

----------------------------------------------------------------------------------------------------
7. Confidential comments for the editors, not to be sent to the authors
(optional)
----------------------------------------------------------------------------------------------------

The core proof-idea has a bug in it. Since it seems the bug can be fixed, I
suggested acceptance with major revisions. If you agree, I would suggest you
instruct the authors to rewrite the proofs to be much clearer (the style of [5],
co-written by one of the authors on the same topic, is very good), give many
more carefully-worded intuitive explanations of definitions and proof ideas, and
proofread the paper very carefully before resubmitting.

