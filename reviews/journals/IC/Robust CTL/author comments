

Dear Sasha and Franco,

I am forwarding to you the revised version (elsart3.pdf) of the paper (c4568-original.pdf) you have reviewed for I&C while ago. For some unexplainable reason I did not get it at the time the authors submitted it more than three months ago! For this reason, I would be delighted if you can send me your comment as soon as you can.

I also attach your first-round reviews on this paper. Following your suggestions, the paper was accepted with major revision.

Cheers,

Nello
***********
Re: "Sublogics of a Branching Time Logic of Robustness," John McCabe-Dansted, Clare Dixon, Tim French and Mark Reynolds, C4568

Dear Nello,

The authors of the above paper have sent a revision (attached) and response to the two reviews (in the message below). I added a series of asterisks to make it easier to see when the response to the first review ends and the second response begins. We would be grateful if you could let us know whether the reviewers' comments have been addressed.

Best regards,
Becky Shepardson, Assistant Editor
Information & Computation

-------- Forwarded Message --------
Subject: 	Re: [Iandc] Information & Computation ms C4568
Date: 	Wed, 17 May 2017 16:04:34 +0800
From: 	John <john.mccabe-dansted@uwa.edu.au>
To: 	Information & Computation <iandc@csail.mit.edu>
CC: 	Mark Reynolds <mark.reynolds@uwa.edu.au>


Hello,
    As suggested I resubmit this paper. I address the reviewer comments 
point by point below.

C4568_RefA.txt

-------------------------
Summary of Paper
-------------------------

The logic RoCTL* (Robust CTL*) is a logic for reasoning about robustness 
in the presence of errors. For example, it can express that "for every 
error-free path, it is always the case that, even if one error is 
introduced, and if the path diverges, the divergent path still satisfies 
\phi". The syntax of RoCTL* is like CTL* except it has additional path 
quantifiers, specifically the Robustly quantifier R. Moreover, the 
semantics of RoCTL* arise from unfolding Kripke structures in which some 
transitions can be successful and others can have errors. The targets of 
unsuccessful transitions are marked by a special atom. It has been 
argued in earlier work that RoCTL* can naturally and succinctly reason 
about systems and situations/protocols in which failures may occur and 
yet the (original) specification is still satisfied.

It is known that satisfiability and model checking of RoCTL* are 
decidable, and that RoCTL* is expressively equivalent to CTL*, but 
non-elementarily more succinct than CTL*. The main open question (not 
solved in this paper) is whether RoCTL* has an elementary decision 
procedure. This motivates the study of fragments and logics related to 
RoCTL*. Indeed, one of the stated motivations is to find fragments of 
RoCTL* that one can prove have elementary (or efficient) decision 
procedures. To this end, the authors identify a CTL-like fragment called 
State-RoCTL* that has the same complexity (of satisfiability and model 
checking) as CTL. Another related logic is the bundled-variant RoBCTL*. 
This logic has the same syntax as RoCTL* but the semantics are 
different: paths are restricted to a given set of paths (that are suffix 
and fusion closed). The authors prove that satisfiability is decidable 
using an extension Reynolds' tableaux procedure for CTL*. They also 
identify syntactic fragments of RoBCTL* for which satisfiability is 
elementary.  Finally, another CTL-like fragment Pair-RoCTL* is 
considered, which turns out to be much more like CTL* than CTL.

--------------
Evaluation
--------------

The paper is within the scope of I&C and readers of this journal will 
find it relevant.

The results seem novel, and the main results were presented in 
conferences (TIME and JELIA) and one of the authors' PhD Thesis.

The paper seems to have been hastily put together and requires much work 
to bring it into publishable form. In particular (see comments to the 
authors, below)
- some notations can be improved to help the reader quickly grasp the 
nature of the objects,
- some important definitions are missing,
- the main objects, including RoCTL*, should be better motivated,
- the contributions are not spelled out clearly enough,
- some sections/paragraphs appear out of the blue which makes them hard 
to follow,
- some of the proofs require cleaning and more care, and all of the main 
proofs require carefully worded proof ideas to make them more digestible.

Due to the poor organisation of the proofs, I was not able to verify all 
of them line by line.
Having said that, the proof techniques all have to deal with the 
operator R which has the unusual
property that R\phi is a path-formula, while R is a path quantifier. 
This leads, e.g., to an interesting variation
of the tableaux proof for CTL* of [8].

I suggest acceptance, subject to major revisions.

-----------------------------------------------------------------------------
RESPONSE: I have added material based on the reviewers suggestions, 
expanding the paper from 45 to 58 pages (despite trimming a subsection). 
This has included adding proof ideas, improving some proofs and minor 
restructing. I give more detail by responding point by point to the 
General comments below.

---------------------------------------------
General comments to the authors
---------------------------------------------

-----------------------------------------------------------------------------
-- It would help the reader if the examples (of formulas, as well as the 
intended scenarios where the uogics might be applied) were more fleshed out.
RESPONSE: We have added the example of a Sea Guard, and some more text 
in the first example.

-----------------------------------------------------------------------------
In particular, you should clearly explain (or give examples to 
illustrate) what you mean by "error" and "failure"? Are these the same 
notions? I suppose so, although "failure" suggests that system crashes 
(rather than, e.g., some sensor giving the incorrect reading, or some 
process failing to make an action in time).
RESPONSE: I now explain that failure transitions represent action that 
the system shouldn't take, I limit the use of "error" to a single 
example and add the text "In the following example, if the system does 
not behave as it should (i.e. follows failure transitions) a particular 
error state may occur."

-----------------------------------------------------------------------------
Also, it seems you intend that R quantifies over paths which are 
deviations of the original path, even if no error was introduced, and 
which are error free from the point of deviation. It is not clear why 
this is a natural definition. This definition should be justified (by 
examples, by clearer explanations, or by citations).
RESPONSE: Currently I say "Deviations are intended to represent possible 
failures we may wish to be able to recover from, and if our system is 
robust to failures we also want it to be robust in the face of correct 
transitions. For this reason we allow the new transition added at step i
   to be a success as well as a failure."

I have moved this sentance into a new paragraph to emphases it and have 
added the citations, figure and text : "In addition the robustly 
operator we will define quantifies over the present path as well as 
deviations from that path. This is because it would be odd to say that a 
goal is robustly achieved if it will not be achieved. For example in 
Figure 3 all deviations (and deviations of deviations etc.) of \sigma
   reach p, but not \sigma itself. It would be odd to say that \sigma 
robustly ensures that we would eventually reach a p. These conventions 
are also followed by previous work on RoCTL* (McCabe-Dansted et al., 
2015; French et al., 2016)."

-----------------------------------------------------------------------------
Also, I think there should be a good discussion about what you mean by 
"Robust System".
  E.g., you say on page 5 that a robust systems often has an implicit 
fairness constraint, and then give an example. The paper would be 
greatly enhanced if this was part of a deeper discussion about the types 
of systems to which these logics are targeted.
RESPONSE: I have added "The RoCTL* logic is designed to represent robust 
systems. That is, systems that ensure that some goals are met even in 
the face of a certain number of failures occurring.", and as discussed 
above enhanced the examples section. The new related work section may 
help a little too.

-----------------------------------------------------------------------------
-- Please discuss the relationship between your work and related works 
more fully.
RESPONSE: I have added a new Related Work Section

-----------------------------------------------------------------------------
E.g.,
- You suggest that in previous work on this logic [1,5,etc], it is shown 
that RoCTL* is expressively equivalent to CTL* (and in fact a 
conservative extension of CTL*). It is worth pointing out what this 
means exactly. In particular, these logics are expressively equivalent 
over which set of models?
RESPONSE: This has been codified more precisely by a trivial variation 
of BCTL*/CTL* interpreted over models which may have the "special" atom 
v, along with an agument that this does not add real expressive power to 
CTL*.

-----------------------------------------------------------------------------
- The paper Faella, Napoli, Parente, 2010 "Graded ATL" deals with 
counting paths in a reactive setting, and the paper Aminof, Murano, 
Rubin, 2014: " Satisfiability and Model Checking of CTL* with Graded 
Path Modalities" deals with path quantifiers that can express certain 
forms of robustness that can not be expressed in CTL* (see also the 
references in this paper).
RESPONSE: The new related work section included two paragraphs 
discussing Graded logics.

-----------------------------------------------------------------------------
- You provide a tableau proof following Reynolds. Since the 
automata-theoretic approach to temporal-logics is well-established, you 
might discuss why you chose a tableau proof. Are there difficulties 
giving an automata-theoretic proof?
RESPONSE: We add:
"The bundled variant is of interest as BCTL* has a simple tableau with 
optimal (2EXPTIME) worst case performance, and a tree based 
implementation that performs much better in practice than one would 
expect from the worst case performance bounds.
By comparison the only decision procedure for CTL* that combines good 
real world performance with optimal worst case results is neither a 
simple tableau or automata technique, but rather a
combination of a tableau and an parity game solver \cite{FLL10}."

-----------------------------------------------------------------------------
-- Some notations should be improved. For instance, delta^0, \delta^+, 
\delta^\omega also depend on $B$, and this should be made explicit (at 
least in the definitions).
RESPONSE: Now reads: "We define delta^omega(w) to be the set of all 
fullpaths in B starting with world w" etc.

-----------------------------------------------------------------------------
Other examples of poor notation are RoCTL*^S and State-RoCTL* --- please 
choose one.
RESPONSE: We now just use State-RoCTL (and Pair-RoCTL instead of RoCTL^S)

-----------------------------------------------------------------------------
-- There are many statements in the paper of the form "logic L is 
expressively equivalent to logic Q" or "logic L is an extension of logic 
Q". The problem is that the logics L and Q may be over different classes 
of models. E.g., CTL is over kripke-structures while RoCTL^S is over 
ROCTL^S structures. Thus you should clearly explain what you mean by 
"expressively equivalent" and "an extension of".
RESPONSE: I now have the text:

Proposition 21. RoCTL* (RoBCTL*) has the same effective expressive power 
as CTL* (BCTL*).

Recall that RoCTL* is defined here as a syntactic restriction of RoCTLv* 
that is not allowed to include the special atom \Viol
   in formulas. So clearly RoCTLv* is at least as expressive as RoCTL* 
(technically it is strictly more expressive as \Viol
   cannot be translated into RoCTL*). Thus CTLv* is also more expressive 
than CTL*. Since RoCTL* is a syntactic extension of CTL* it is intuitive 
that it would be at least as expressive as CTL*. Indeed interpreted over 
a CTL-structure without any the special atom \Viol
   in the valuation of any states, RoCTL* become equivalent to CTL*, and 
the \O
   and \robust operators become equivalent to A
  . Thus we see that the expressive power of RoCTL* is somewhere between 
that of CTLv* and CTL* (without \Viol
  ). However since CTLv* does not have any special operators that rely 
on the special atom \Viol
  , we see that \Viol   is only special in that it is guaranteed to 
satisfy \A\G\E\N\neg\Viol
  . Satisfying \A\G\E\N\neg\Viol
   isn't very exciting, particularly since it is satisfied by any 
structure that does not have \Viol
   in the valuation of any states. Thus RoCTL*, CTL* and CTLv* may be 
seen as having the same effective expressive power.

-----------------------------------------------------------------------------
-- It seems that RoBCTL* is a semantic sublogic of RoCTL*. This should 
be stressed. What is the relationship between these logics wrt 
satisfiability? are they expressively equivalent?
RESPONSE: ADDED:
"RoCTL* can be thought of as the restriction of RoBCTL* where the bundle 
must include all possible paths in the structure.
Under this interpretation, RoBCTL* and RoCTL* are not just trivially 
expressively equivalent but truly equivalent when interpreted over 
RoCTL* structures."
and
"Similarly, any formula that is satisfiable in RoCTL* is satisfiable in 
RoBCTL*."

-----------------------------------------------------------------------------
Also, you should discuss the model-checking problem for RoBCTL* or 
explain why it was omitted. Does it make sense to talk about finite (or 
finitely-presentable) RoBCTL*-structures?
RESPONSE: There are no finite BCTL*/RoBCTL* structures, since a bundle 
always has at least one fullpath, and that fullpath is infinite. As such 
there is no "RoBCTL* model checking" problem but a multitude of problems 
depending on which representation of RoBCTL* models you want.
ADDED:
We have not given a model checking procedure for RoBCTL*. RoCTL* can be 
model checked by translating the formulas into CTL*, and then model 
checking the resulting formulas McCabe-Dansted et al. (2015). RoBCTL* 
can likewise be translated into BCTL*; however, whereas CTL* has the 
bounded model property Emerson et al. (1984), BCTL* models have bundles 
which are never finite. Thus the RoBCTL*/BCTL* model checking property 
cannot even be defined without reference to some particular finite 
representation BCTL* models. Although BCTL* tableaux provide such a 
finite representation, they may not be the most natural representation.

[[FEEDBACK]] RoBCTL*-structures are not finite. The tableaux for RoBCTL* 
are finite though, which does provide *a* finite representation of 
RoBCTL* models. We can translate the RoBCTL* model checking problem into 
BCTL* (alas a non-elementary translation).

I could sketch a possible model checking algorithm for BCTL*. I think 
the following would work
- Take the Hue-Colour representation of a BCTL* model such as one 
created by the Tabelaux algorithm.
- For each subformula psi (starting with the smallest) and hue h in C in 
the tableau we could:
   1) Add psi to the instance of h in C if all paths described by h from 
C satisfy psi
   2) Add ~psi to the instance of h in C if no paths described by h from 
C satisfy psi
   3) replace h with h+psi and h+(~psi) in C other wise.
As with CTL* model checking algorithms, this algorithm for BCTL* should 
be exponential in the size of the formula, and linear in the model.

It might be more natural to use automata (alternating Buchi perhaps) for 
the models, but showing that it can be translated would be an other issue.

Would this help?

-----------------------------------------------------------------------------
-- Please provide a table summarising the known results and your 
contributions. This makes it much easier for readers to grasp your 
contributions. An alternative is to add a bold subheading at the end of 
the introduction called "Our contributions" (i.e., before par 4 on page 
4) and to make that paragraph much more precise (e.g., replace "at least 
as hard to reason about" by what you actually prove). Also, the 
relationship between the present work and the logics with v subscripted 
(e.g., RoCTL*_v) should be made more explicit, and mentioned in this 
summary.
RESPONSE: Added subsection "1.1 Our contributions"  (although the 
official style for subheadings is italics rather than bold.)

-----------------------------------------------------------------------------
-- The motivation for bundled logic (pages 4 and 5) could be better 
structured. E.g., you suggest that one reason for studying them is that 
it is easier to find Tableau proofs. Ok, but what are the advantages of 
Tableau proofs over, e.g., automata-theoretic proofs?
  Also, the last three paragraphs of that section (i.e., from "In 
section 5" to "will hold.") do not discuss the motivation for bundled 
logics, but rather they discuss how the tableau construction of the 
present paper differs from that in Reynolds' paper. This discussion 
should be labeled as such, and perhaps moved to a more appropriate place 
(perhaps in the same section as the Tableau proof).

RESPONSE: The paper is getting long, and bundled logics have been better 
motivated elsewhere, so we have removed this section. In discussion of 
bundles we have added:

"Motivation for bundled logics has been given in other publications. For 
example, it can be difficult to adapt some satisfiability checking 
techniques to non-bundled logics with the limit-closure property 
(Emerson et al., 1982), and certain fairness constraints can be 
naturally expressed in a restricted bundled logic BCTL which has singly 
exponential satisfiability checking procedure (McCabe-Dansted et al., 
2014)."

We have also added some examples of Bundles and Robustness in the 
examples section.

-----------------------------------------------------------------------------
  Also, since tableau's are an important part of this paper, it would be 
nice to have a gentler introduction to the proof, i.e., please give the 
general idea of the tableau (what is its shape, how is it labelled, when 
is it successful, etc.), and also, please give an example of a 
satisfiable formula and its tableau.
RESPONSE: I have added
   - "... not a tree, the structure of the tableau is essentially an 
arbitrary graph."
   - "These colours can be thought of as labels, so the labels of the 
tableau are sets of sets of formulas."
   - The tableau for the trivial case \phi=p, this definition takes a 
page and the size of the tableau can grow quickly so I have not 
considered a larger example. I discuss a previous paper which shows that 
converting such tableaux to a tree shape can greatly improve their size 
and performance in practice (though not worst case bounds).

-----------------------------------------------------------------------------
  Also, please give some intuitions/explanations/justifications for the 
definition of a bundle, i.e., why fusion- and suffix-closed are assumed.
RESPONSE: See new Example 12.

----------------------------------------------
Detailed comments to the authors
----------------------------------------------

-----------------------------------------------------------------------------
Please stress in the preliminaries that indexing of paths starts at 0, 
i.e., w_0, w_1, \dots (instead of w_1, w_2, \dots).
RESPONSE: added "Note that the indices start at 0 and can be thought of 
as a distance. "


-----------------------------------------------------------------------------
Page 2:
- You write \box for always and then F for sometimes. Is there a good 
reason to mix these notations?
RESPONSE: No. It is now '\F' (a macro for diamond).

-----------------------------------------------------------------------------
- It would be useful to the reader to say that more examples appear in 
Section 4.
RESPONSE: Done

-----------------------------------------------------------------------------
- I would suggest adding an example scenario. In particular, what is 
"failure" intended to mean? (see comment about page 6 below).

RESPONSE: we added

"Note that a failure transition may not involve the system failing to 
achieve any of its goals. For example, even a real time system may be 
able to recover fully from some fixed number of packets losses, and a 
single bit error in ECC memory may cause no harm. A particular failure 
transition may happen to have a beneficial effect, such as flipping a 
bit that has already been flipped once. However, given a assumption that 
the number of failures is no more than some number n, we may be able to 
verify that a system achieves some/all of its goals."

(and new examples in the Examples section)

-----------------------------------------------------------------------------
- par 4: you state that full RoCTL* is decidable but, a) you have not 
described what full means,
RESPONSE: Full computation tree logic (CTL*) is CTL without restrictions 
on syntax so the intent was to put empahsis on this being RoCTL* rather 
than RoCTL, but it isn't necessary so I have just removed it.

-----------------------------------------------------------------------------
  b) please be explicit if you mean that satisfiability is decidable or 
model-checking is decidable.
RESPONSE: My understand was that the decision problem for a logic by 
default means satisfiability/theorem proving, but in any case I now 
write that "...the satisifability problem for RoCTL{*} is decidable."

-----------------------------------------------------------------------------
  Moreover, it is helpful to the reader to say a bit more about these 
translations, e.g., what do they preserve (truth? satisfiability?).
RESPONSE: It now reads "It provided truth and satisfiability preserving 
translations of..."

-----------------------------------------------------------------------------
- par -1: the phrase "limit closure is (not) valid in a logic" is hard 
to understand. Can you rephrase it? What is "limit closure" a property 
of? (the set of runs that are considered by path quantifiers?)
RESPONSE: I now add "informally the limit closure property states that
if we have an infinite sequence of states σ such that for all n the 
first n states
form an allowed path, then the infinite sequence σ forms an allowed 
path." to the introduction.

-----------------------------------------------------------------------------
Also, it would be helpful to state here that RoBCTL* is a semantic sublogic.
RESPONSE: Done.

-----------------------------------------------------------------------------
Also, please formally define "limit closure".
RESPONSE: See new Definition 5.

-----------------------------------------------------------------------------
Page 3: "need to be allowed" --> "are allowed".
"subset of those of RoCTL*" ---> "subset of those allowed in RoCTL*"
"expressive fairness" --> "express fairness"
RESPONSE: Done

-----------------------------------------------------------------------------
The sentence "The obvious way ..." must be rewritten. What is this way? 
What is the contradiction?
RESPONSE: Replaced with "The direct specification of this in CTL{*} or 
RoCTL{*} contradicts the limit-closure property."

-----------------------------------------------------------------------------
Also, you seem to imply that bundled logics can easily handle 
probabilistic reasoning. If so, this is a point worth stressing!
RESPONSE: I think this would be a rather strong claim. I explictly 
mention the weakness of bundles of represenging probabilistic reasoning 
by adding: "Note that (Ro)BCTL* are not designed to represent 
traditional numerical probabilities, for examples bundles cannot 
distinguish between $p=0.1$ and $p=0.99$."

-----------------------------------------------------------------------------
Definition 6:
-- You write "w in B" (twice). At first I thought you meant that $w \in 
B$ (which would have been a typo). Now I see that you mean that the full 
path is in B. Please rewrite to make this clear.
RESPONSE: I think rearranging the sentance as follows makes that clearer:
    We define \SF(w) to be the set of all fullpaths in B starting with 
world w

-----------------------------------------------------------------------------
On pages 2 and 3 you refer to logics that are "amenable to automated 
reasoning" and "a little closer to being usable". Please be explicit: 
will the reader see decision procedures with (relatively) low 
complexity? Or will the reader see other arguments hat these logics are 
usable (e.g., decision procedures that are easy to implement).
RESPONSE: This is discussed more later. I have added
"For example, we will discuss how restricting the syntax of RoCTL* to 
state-formulas makes the model checking and satifiability problems as 
easy as those for CTL."
here

-----------------------------------------------------------------------------
Page 3:
par -2: You state that CTL is frequently used. Please be explicit. Used 
in tools? in papers about verification?
RESPONSE: I have added: "the most famous example of the use of CTL is 
the proof the 1995 verification of the Futurebus+ cache coherence 
protocol \cite{Futurebus}. However, later papers have tended to also use 
approaches based on CTL rather than the full CTL* 
\cite{DBLP:conf/vlsid/2002,DBLP:journals/trob/LahijanianAB12}."

-----------------------------------------------------------------------------
Satisfiability of CTL is EXPTIME-COMPLETE (not just EXPTIME).
RESPONSE: OK replaced "can be performed in singly exponential time" with 
"is EXPTIME-COMPLETE".

-----------------------------------------------------------------------------
You write "model checking CTL* is singly exponential in the length of 
the formula". What about the size of the Kripke structure?
RESPONSE:  I add "model checking for CTL{*}
is singly exponential in the length of the formula, but for CTL we
can model check in time linear in the length of the formula; in either 
case we can model check in time
linear in the size of the model."

-----------------------------------------------------------------------------
par -1:why do you not call Pair-RoCTL simply RoCTL?
RESPONSE: Because we present two CTL like restrictions, Pair-RoCTL and 
State-RoCTL

-----------------------------------------------------------------------------
Page 4: par 1: The phrase "CTL model checker of [15]" sounds like it 
refers to a tool that does model checking, rather than an algorithm.
RESPONSE: replaced with "CTL model checking algorithm of"

-----------------------------------------------------------------------------
par 2: "not expressively equivalent" --> "not truth preserving" (?)
RESPONSE: Done

-----------------------------------------------------------------------------
par 3: "With current technology State-RoCTL is tractable for larger 
problems than CTL*" does not make sense to me. Please 
rewrite/rephrase/be more explicit. What does "larger problems" mean? 
Larger in size? Larger in scope? Larger in quantity?
RESPONSE: replaced "problems" with "formulas"

-----------------------------------------------------------------------------
par -2: It would not hurt to remind the reader what "bundled variant" 
means, and what "limit closure" refers to.
RESPONSE: This Now reads:
  "RoBCTL{*} is a bundled variant of RoCTL{*}; that is, the models have 
a bundle of paths that the path quantifiers of the logic are restricted 
too.  The bundle need not satisfy the limit closure property, or in 
other words there may be a path $\sigma$ through the structure such that 
for any $n$ there is a path $\pi$ in the bundle such that the $\pi$ and 
$\sigma$ share the first $n$ steps, but $\sigma$ itself is not in the 
bundle."

-----------------------------------------------------------------------------
Page 6:
The sentence "Informally it may be possible to enter a state labelled 
with v, but it is forbidden to do so; entering such a state will be 
considered a failure." needs fleshing out, since it is confusing as it 
is written. In what sense is it forbidden to enter a state labeled v? 
What forbids this? Also, what is "failure" supposed to mean here? Does 
it mean that the system crashes? or that some sensor gives the incorrect 
reading but the system still runs?
RESPONSE: Perhaps the updated text is more clear:
The \Viol  atom will be used to represent failure transitions. In the 
terminology of Deontic logic, it is forbidden to follow a path with a 
failure transition. While the interpretation of forbidden depends on the 
domain of application, from the point of view of robust systems it is 
natural to think of a failure transition being the result of a event not 
desired by the designer of the system, but that the designer wishes to 
account for, such as a corrupted network packet or mistake by a user of 
the system.

-----------------------------------------------------------------------------
Page 7:
-- line -2: please say how sigma is quantified.
RESPONSE: I have added that pi and sigma are "in the bundle B"

-----------------------------------------------------------------------------
-- Definition 7: please stress that if pi is a deviation of sigma then 
pi has only finitely many failures.
RESPONSE: DONE: Added "Note that deviations always have a finite number 
of failures along the path, since i
   is always finite."

-----------------------------------------------------------------------------
Page 7 and 8: You write that you define RoCTL* and, in parenthesis that 
you define RoBCTL*, but then give just a single definition. What then is 
the definition of RoBCTL*? I assume you mean that the syntax is the same 
but the semantic differs. If this is the case, please say so here.
RESPONSE: I now write "Bundled logics are semantic variants, that share 
the original syntax. Where p
   varies over \Var, we define the well formed formulas of RoCTL* and 
RoBCTL* formulas according to the following abstract syntax..."

-----------------------------------------------------------------------------
Page 8: Please rephrase the definition/description of RoBCTL*_v. I 
understand it to mean that this logic does allow formulas to explicitly 
contain v. Also, what is the relationship between the logics in [21] and 
RoBCTL*_v? Also, how is v useful/used if the logic can't talk about it?
RESPONSE: Now reads "... and the behaviour of the \O
   and \robust operators do depend on \Viol.
   We call the logic without the restriction on \Viol
   appearing in formulas \RoBCTLvstarLogic{}.

-----------------------------------------------------------------------------
[Style] It seems you should decouple this comment about "v" from the 
last sentence, i.e., "The \neg, \wedge, ... from CTL" otherwise one 
might think (as I did) that this last sentence is specific to RoBCTL*_v.
RESPONSE: Added a paragraph break here.

-----------------------------------------------------------------------------
Page 8:
-- Definition of Syntax. Why is (\phi \wedge \psi) not a state formula?
RESPONSE:  They are now.

-----------------------------------------------------------------------------
-- The style of the semantics are a little unusual. Is there a good 
reason not to mimic the style of the usual definition of CTL*, i.e., 
define state formulas \phi and path formulas \psi, and the define M,w 
\models \phi and define M,\pi \models \psi?
RESPONSE: The reason was that the definition that doesn't include this 
distinction is simpler and the CTL* semantics themselves don't directly 
care about state-formulas. Anyway I have changed this now as suggested

-----------------------------------------------------------------------------
-- Please stress that, unlike O\phi and A\phi, the formula R\phi is a 
path formula (not a state formula).
RESPONSE: Added: "Note that unlike \A\phi and \E\phi, the a formula of 
the form \robust\phi is a path formula rather than a state-formula"

-----------------------------------------------------------------------------
The difficulty is one of notation: since \A and \O and \R all use the 
same font, it is natural for the reader to assume that they are the same 
types of objects, i.e., path quantifiers \X such that \X \phi is a state 
formula.
RESPONSE: I have switched back to my earlier notation of 
``\blacktriangle'' instead of R

-----------------------------------------------------------------------------
Definition 9: I think you meant to write \phi instead of \tau(\phi) in 
the second line of the dfn.
RESPONSE: Fixed

-----------------------------------------------------------------------------
Page 10: Lemma 13 has a typo. I guess one of the RoBCTL*s should be RoCTL*.
RESPONSE: Fixed

-----------------------------------------------------------------------------
-- Definition 14: This definition could be tightened a bit, namely,a) 
"the representation of", b) you give three sentences describing three 
overloadings of the notation |x| (please make this clearer).
RESPONSE: I think only two: size of sets and formulas.
In any case it now reads:
"As normal where S
   is a set we define the size \left|S\right| of S
   as the number of elements of S. For a formula \phi,
   we define the length \left|\phi\right| of \phi
   to be the total number of occurrences of symbols in the 
representation of \phi
   excluding parentheses.

-----------------------------------------------------------------------------
-- if it is not possible to define State-RoCTL* before using it, at 
least give an informal description here.
RESPONSE: I now define State-RoCTL* first

-----------------------------------------------------------------------------
-- what does "RoCTL* model" refer to? a kripke structure?
RESPONSE: In the current draft I have replaced this with "system"

-----------------------------------------------------------------------------
-- Example 15, item 2: "was empty" --> "is empty".
RESPONSE: Fixed

-----------------------------------------------------------------------------
In the description you imply that a failure refers to forgetting to fill 
the bowl. In the formulas there is no mention of this. What do errors 
refer to then?     What can be said about the set of formulas 1 through 5?
RESPONSE: I now write
"In (2) above note that \E\N\neg b would be equivalent \prone\N\neg b. 
(1) and (3) could be formulated as \tA\G(d\rightarrow\A\N\neg d) and 
\A\G((\neg d\wedge b)\rightarrow\A\N b) respectively in RoCTL* (but not 
State-RoCTL*). (4) Represents “If at most one failure occurs” using \O 
(In a perfect future that ought to occur, that is one with no failures) 
and \eA (even if an additional failure occurs. (5) is a trivial formula 
that does not use any operators, but simply states b, indicating that b 
is true now (but might not be true in the future). Note that failure is 
a property of transitions in the model, and is not explicitly referenced 
in the formulas. A failure is represented by following a transition that 
we ought not to, one that leads to a state labelled with \Viol. We will 
present below a model where failure represents forgetting to fill the 
cat bowl.
..."
We can construct a model M=\bctlstruct of this example. We let S=\left\{ 
w,w',u,u'\right\} , g\left(w\right)=\left\{ b,d\right\} , 
g\left(w'\right)=\left\{ b\right\} , g\left(u\right)=\left\{ 
\Viol\right\} , g\left(u'\right)=\left\{ \Viol,d\right\} , R=\left\{ 
\left(w,w'\right),\left(w',w\right),\left(w,u\right),\left(u,u'\right),(u,w),\left(u',w'\right),\left(u',u\right)\right\} 
, and B be the set of all possible fullpaths through R. Where \sigma is 
w,w',w,w',\ldots we see that \sigma represents the case where no 
failures occur, and we keep the cat bowl full at all times. We see that 
this path also achieves the requirement (4) above, because a single 
failure (represented by reaching a \Viol atom) may result in reaching 
state u where the cat bowl is not full, but that does not matter because 
it is not dinner time. It would take an additional failure to reach u' 
where it is dinner time, but the bowl is still not full."

-----------------------------------------------------------------------------
- In both the examples I feel that it would be clearer if the logics 
explicitly expressed something about $v$. Otherwise, you should give a 
model M of the formulas that has $v$ on some of its states.
RESPONSE: We don't directly access $v$ because this allows us to think 
of $v$ denoting a different type of transition rather than an atom.

I now write "...
We can construct a model M=\bctlstruct of this example. We let S=\left\{ 
w,w',u,u'\right\} , g\left(w\right)=\left\{ b,d\right\} , 
g\left(w'\right)=\left\{ b\right\} , g\left(u\right)=\left\{ 
\Viol\right\} , g\left(u'\right)=\left\{ \Viol,d\right\} , R=\left\{ 
\left(w,w'\right),\left(w',w\right),\left(w,u\right),\left(u,u'\right),(u,w),\left(u',w'\right),\left(u',u\right)\right\} 
, and B be the set of all possible fullpaths through R. Where \sigma is 
w,w',w,w',\ldots we see that \sigma represents the case where no 
failures occur, and we keep the cat bowl full at all times. We see that 
this path also achieves the requirement (4) above, because a single 
failure (represented by reaching a \Viol atom) may result in reaching 
state u where the cat bowl is not full, but that does not matter because 
it is not dinner time. It would take an additional failure to reach u' 
where it is dinner time, but the bowl is still not full."

-----------------------------------------------------------------------------
Page 11, dfn 17: why are the subscripts used here?
RESPONSE: Subscripts have been removed

-----------------------------------------------------------------------------
dfn 18: why is the enumeration needed here? you can define \xi without it.
RESPONSE: Removed

-----------------------------------------------------------------------------
dfn 19: why do you use the notation $O$ for next as well as in $O^-1$ 
and $O^*$? What is the intuitive meaning of $O^-1$ for each of the more 
complicated formulas in the definition (i.e. Until and \R). What is the 
relationship between O^-1 and the past operator "Yesterday"?
RESPONSE: I have added:
We now wish to give an approximation X^{-1}
   of the inverse of the X
   operator. There are no past-time operators in RoBCTL*, so it is not 
possible to represent X^{-1}
   in RoBCTL* without knowing what atoms were true at the previous 
state. Thus we first define X_{a}^{-1}
   where a is a set of atoms

-----------------------------------------------------------------------------
Pages 12,13: You use * in two seemingly different ways. One in S*T and 
the other in O*. This would not be a problem except that the paragraph 
after dfn 23 seems to mix them up.
RESPONSE: I now use S?T as * has perhaps been used too much.

-----------------------------------------------------------------------------
Page 13: dfn 22: please explain why you use $O$ here.
RESPONSE: Added: "Recall that \Viol indicates that the previous 
transition was a failure, and so we can present “the next transition is 
a success” with \gamma=\N\neg\Viol."

-----------------------------------------------------------------------------
Page 14: It would be easier to follow if Lemma 28 were placed closer to 
definition 23.
RESPONSE: Moved

-----------------------------------------------------------------------------
Also, what does (\dots) inside the proof refer to?
RESPONSE: It refers to
    X_a^{−1} (φ) ∧ (φUψ)
from the defintion of
    X_a^{−1} (φUψ)

In any case I have removed this is it doesn't seem to have made the 
proof clearer.

-----------------------------------------------------------------------------
Page 16:

line 1: rephrase. perhaps, replace the first occurrence of "describes" 
by "relates" and remove "might".
RESPONSE: rephrased

-----------------------------------------------------------------------------
I don't understand the relevance/point of the par after dfn 31.
RESPONSE: Not really needed till proofs. Removed

-----------------------------------------------------------------------------
  Section 5.1. You talk about the tableau, but it has not yet been 
formally defined.
RESPONSE: Now defined a pre-tableau.

-----------------------------------------------------------------------------
Page 17: You refer to a tableau as being "accepted", but this has not 
yet been formally defined.
In dfn 33 you use the word "succeeds", although i gather this means the 
same thing as "accepted".
RESPONSE: We no longer use the term "accepted" in the context of tableaux

-----------------------------------------------------------------------------
Page 18: Lemma 35. Extra space before bold C in proof.
RESPONSE: I would have thought that LaTeX would automatically remove 
double spaces. Manually removed.

-----------------------------------------------------------------------------
Page 19: Please formalise the hypothesis of Cor 40.
RESPONSE: Defined it in terms of BNF

-----------------------------------------------------------------------------
Page 20: That there are any "Real world uses" requires some justification.
RESPONSE: I now write "The potential real world uses for Ro(B)CTL* 
suggested by examples such as those in Section ..."

-----------------------------------------------------------------------------
Section 5.3: RoBCTL*-TAB is not defined. Also, please state the first 
sentence as a proposition or lemma, or simply say that the rest of the 
subsection will prove this fact.
RESPONSE: Now At the beginning of Section 4 we say we will define 
RoBCTL*-TAB, and define it in Definition 46.

-----------------------------------------------------------------------------
Please give an intuition for the definition of thread, esp. item 2.
RESPONSE: We add:

We will now define a thread. Informally, a thread is a sequence which 
demonstrates the existence of a path which satisfies some hue h_{0}
   in some colour c_{0}
  . To do this it provides a sequence of hues and colours in r_{X}
   and R_{X}
  . To understand the need for restrictions on this sequence, recall 
firstly that \left(\alpha\U\beta\right)
   is not satisfied unless we eventually reach a \beta
  . Secondly \neg\robust\alpha
   is equivalent to \prone\neg\alpha
  , and is only satisfied if \neg\alpha
   is true on the current path, or if we can eventually deviate onto a 
path where \neg\alpha
   is satisfied. This second requirement requires a more complex 
definition, as the eventuality that we need to satisfy changes. For 
example, if \prone\neg\N\N p
   is in h_{0}  then this eventuality becomes \prone\neg\N p
   in the subsequent hue h_{1}
  . This is because if there is a deviation needs to \neg\N p
   to ensure \neg\N\N p
   is satisfied in the previous step.

-----------------------------------------------------------------------------
Page 21, lemma 44. missing period.
RESPONSE: fixed

-----------------------------------------------------------------------------
Page 23, lemma 47: you have not defined what it means for a tableau to halt.
RESPONSE: Added: We say that a tableau halts if an algorithm can 
determine if it succeeds in finite time.

-----------------------------------------------------------------------------
Also, why is there a v in RoBCTL_v here?
RESPONSE: This now reads "RoBCTL*-TAB is complete, that is, if φ is 
satisfiable in RoBCTL*_v
then RoBCTL*-TAB halts and succeeds on φ."

The v is still there, but it is hopefully clearer now that this just 
means that the tableau can accept formulas in the RoBCTL*_v syntax 
defined earlier, which does not exclude explict mention of v.

-----------------------------------------------------------------------------
Page 25:
Section 6.1: Why do you introduce yet another notation for pair-RoCTL?
RESPONSE: RoCTL^P is the abbreviated form like CTL* instead of Full 
Computation Tree Logic.
Pair-RoCTL is not too unwieldy, so I no longer define the abbreviation.

-----------------------------------------------------------------------------
Remove "like" from "like in the sense".
RESPONSE: replaced "CTL like" with "similar to CTL"

-----------------------------------------------------------------------------
par -1: The paragraph starting "We note that the translation..." needs 
rewriting.  First, what sort of translation? (cf dfn 9).
Second, I couldn't get the point of the paragraph. A translation from 
LTL to RoCTL^P would not be much simpler than one from CTL*? I suppose 
it depends on what type of translation.
RESPONSE: The paragraph provides some background into e.g. complexity 
results.
To explain how the translation is simpler I add "This translation has 
some special atoms y_{\A\psi}  and y_{\E\psi}. Note that these special 
atoms are not required for translating LTL into Pair-RoCTL"
I note that the translation is a satisfiability preserving translation.

-----------------------------------------------------------------------------
Page 26:
[[Tim suggests...
RESPONSE: Removed

-----------------------------------------------------------------------------
What does it mean for a "subset of states to form a CTL model"?
RESPONSE: "the restriction of the structure to subset of the states".

-----------------------------------------------------------------------------
Page 34: section 7.1. It seems you mean to join pars 1 and 2.
RESPONSE: This would result in a rather long paragraph, but the after 
rewording this break may be more natural.

-----------------------------------------------------------------------------
par 2: You write that "\beta does not occur on \pi_j for j \leq i". 
However I do not understand the reasoning.
RESPONSE: I add "Consider the case where M,\sigma\nforces\alpha U\beta. 
In this case, ..."

-----------------------------------------------------------------------------
Page 35:
Definition 66: Please remove the ambiguity formed by having "(or 
\reverseR)" in parenthesis.
In particular, is \phi < \psi if phi and psi have the same number of 
\reverseR and |phi| < |\psi| but \psi has less R operators than phi?
RESPONSE: We now write: Note that we treat \prone as an abbreviation for 
\neg\robust\neg, so p<\prone p.

-----------------------------------------------------------------------------
Page 36, lemma 68: The sentence starting "Hence there exists an integer 
$i$..." seems to be missing a case, i.e., \sigma_j \not \models \beta 
for all j.
RESPONSE: Added

-----------------------------------------------------------------------------
Also a little later you say that if \sigma \models \alpha \until \beta 
and if \sigma_i \not \models \beta then \simga_i \models \alpha. However 
this reasoning is not correct unless i is the smallest integer k such 
that \sigma_k \not \models \beta.
RESPONSE: Added: "Assume without loss of generality that j is the 
smallest j such that M,\sigma_{j}\nforces\beta"

-----------------------------------------------------------------------------
Page 39: Lemma 69: you forgot to say that \psi is a state-formula.
RESPONSE: Psi doesn't need to be a state formula here. I add "While the 
lemma above holds even if \psi
   is not a state-formula, we will only apply it to state formulas, as 
in the next corollary."

-----------------------------------------------------------------------------
Page 42:
"I think you need a related work section before this. I think you should 
at least compare your work with other logics for robustness, perhaps 
other tableau for branching-time logics. There might be other related 
work you could mention also."... I agree ;);)
RESPONSE: See the new Related Work section.

-----------------------------------------------------------------------------
Again, limit-closed is used and not defined earlier.
RESPONSE: See new definition of limit closure, and new discussion about 
why limit closure is often not formalled defined.

-----------------------------------------------------------------------------
"via reductions into" --> "by reducing to"
RESPONSE: OK, done.

-----------------------------------------------------------------------------
"This tableau"... Which tableau?
RESPONSE: Now write: the tableau for RoBCTL*

-----------------------------------------------------------------------------
"We have shown that every property that can be expressed in CTL* can be 
expressed in Pair-RoCTL, with a minor translation on the structures." 
Please rewrite more clearly/be more explicit. What type of translation 
is exhibited?
RESPONSE: Now write 'We have shown that the addition of a "success 
world" to CTL* models allows every property that can be expressed in 
CTL* to be expressed in Pair-RoCTL'. The mathematical definition was 
given previously in the paper.

-----------------------------------------------------------------------------
What does it mean for CTL* to be "allowed to access the special 
violation atom"?
RESPONSE: Now write: "CTL* when CTL* formulas are allowed to include the 
special violation atom indicates that Pair-RoCTL, CTL* and RoCTL* all 
have similar expressivity."

-----------------------------------------------------------------------------
Par -2 talks about Pair-RoCTL. But then at the last sentence it suddenly 
talks about State-RoCTL. This is a bit jarring. Perhaps rewrite to make 
the connections clearer.
RESPONSE: This was intended to lead into the next paragraph. Since it 
didn't help make the text read better I removed it.

-----------------------------------------------------------------------------
Par -1: You call the translation "efficient" and then "linear". Is this 
on purpose?
RESPONSE: I now write State-RoCTL* has a linear length 
satisfiability-preserving translation into CTL that is efficient to compute.

-----------------------------------------------------------------------------
What "trivial modifications"?
RESPONSE: These were defined earlier in the paper. I have added
"that is recursively adding each p_{\alpha} atom in the translation at 
states of the model where \alpha is satisfied"

Another approach would be allowing the input CTL formula to be 
represented as a Directed Acyclic Graph, but I haven't given
details on how to do that.

*********************************************************************
C4568_RefB.txt
The paper investigates sublogics of RoCTL*, a flavor of deontic logic 
used to express robustness in addition to deontic operators. In 
particular, the authors provide a tableau for RoBCTL*, investigating its 
complexity, and characterizations of Pair-RoCTL (a CTL-like restriction) 
and State-SoCTL*.
The topic is relevant and has a number of practical applications. 
However, the current version of the paper requires major corrections 
before it can be accepted for publication. In particular, in addition to 
the detailed comments listed below:

     •    I think that the paper could benefit from a running example, 
or at least a section with a concrete example of how specification 
patterns in the various sublogics could be employed to characterize 
properties of systems. Some examples appear in the paper, but they are 
currently spread in different sections.
RESPONSE: We have enhanced the example sections with more examples, and 
have used one example in three forms (Examples 26-28) for RoCTL*, 
RoBCTL* and State-RoBCTL.

     •    Partially related to the previous point: the authors should 
clarify the difference with their previous work. Again, some hints are 
provided (for instance, page 24: “Case 1 and 2 below are similar to […] 
[8]. Case 3 is original”): I think it would be better to add a paragraph 
in the introduction to clarify these extensions. The running example 
mentioned in the previous point could be used to clarify the new 
contributions.
RESPONSE: There is now an "Our Contributions" subsection of the 
introduction.

     •    The paper needs to be proofread. Is it possible that the wrong 
version was submitted for revision? I found authors’ notes that should 
have been removed before submission, in addition to several typos and 
typesetting issues.
RESPONSE: We have disable Authors notes etc. proofread and grammar 
checked the paper.

Detailed comments:
     •    In the list of authors the superscripts for affiliations 
appear at the end of the list of authors.
RESPONSE: fixed

     •    Abstract: “we show that we there is a linear…” -> rephrase
RESPONSE: We now write: "We show that there is"

------------------------------------------------------------------------------
     •    p.3: “bundled logics can expressive fairness” -> can express
RESPONSE: done

------------------------------------------------------------------------------
     •    p. 4 and 5: this section is a repetition of the introduction. 
Some phrases are copied verbatim (e.g., “Hoverver, (almost surely) […]”)
RESPONSE: This section has been removed

------------------------------------------------------------------------------
     •    p.9: “a satisfiability preserving translation is not 
interesting unless it is efficient” -> clarify the notion of “efficient” 
(this is probably not in the sense of “computationally efficient”).
RESPONSE: I add "efficient, not only in terms of length but also in 
terms of complexity"

------------------------------------------------------------------------------
     •    p.9 and in several other places in the paper: remove the 
authors’ names from citations, unless they are needed. For instance, “an 
extension of UB logic that added an until operator Emerson and Halpern 
[18]” should be  “an extension of UB logic that added an until operator 
[18]” or “Emerson and Halpern [18] proposed an extension of UB logic 
etc…”. Another example on page 11: “an extension of Reynold’s Reynolds 
[8] tableau…"
RESPONSE:   Done

------------------------------------------------------------------------------
     •    Lemma 13 on p.10: “\phi will be satisfiable in RoBCTL* iff it 
is satisfiable in RoBCTL*” is tautological.
RESPONSE: One of them should be RoCTL*

------------------------------------------------------------------------------
     •    p.11, last line of section 4: can you clarify the 
formula \reflectbox{R} \diamond e \implies \diamond w? it seems to me 
that e could become true before w along a path satisfying this property, 
isn’t and until formula needed here?
RESPONSE: This has now been expanded into an example of its own.

------------------------------------------------------------------------------
     •    p.13, Definition 23: was \delta defined?
RESPONSE: It was a typo. It is \alpha now.

------------------------------------------------------------------------------
     •    Definition 26: Isn’t the function h a function of \phi as 
well? Shouldn’t it be h(\pi,\psi)?
RESPONSE: Well, since we are defining a tableau for \phi, we could take 
out all mention of \phi and just treat
\phi as a fixed formula. However, for consistancy with the remainer of 
my paper I now use h_\phi(\pi).
We also removed unnecesary use of "h" before it was defined.

-------------------------------------------------------------------------------
     •    p.17, “we let the set S’ of colours equal C_{\phi}” -> equal to
RESPONSE: "equal to" doesn't sound grammatically correct to me, I have 
used "be equal to".

-------------------------------------------------------------------------------
     •    p.20: Beginning of section 5.3, I don’t think the acronym 
RoBCTL*-TAB was defined. I understand what it is, but it should probably 
be defined.
It is now defined.
     •    p.26: remove the note inside Definition 51.
     •    p.27: “We denote \alpha is a subformula of \beta by” -> we 
denote that
     •    p.30: fix right margin in second item
     •    p.31: Lemma 58, “structure structure” -> remove one copy
RESPONSE: The five above typos have been corrected as suggested.

-------------------------------------------------------------------------------
     •    p.42. Remove the internal note (first paragraph of 
conclusion). In fact, I agree with its content: you should add  a 
related work section. This could also address my second point in the 
general comments above.
RESPONSE: See new Section 7 "Related Work".





C4568 - Revision1.txt

-------------------------
Summary of Paper
-------------------------

The logic RoCTL* (Robust CTL*) is a logic for reasoning about robustness in the presence of errors. For example, it can express that "for every error-free path, it is always the case that, even if one error is introduced, and if the path diverges, the divergent path still satisfies \phi". The syntax of RoCTL* is like CTL* except it has additional path quantifiers, specifically the Robustly quantifier R. Moreover, the semantics of RoCTL* arise from unfolding Kripke structures in which some transitions can be successful and others can have errors. The targets of unsuccessful transitions are marked by a special atom. It has been argued in earlier work that RoCTL* can naturally and succinctly reason about systems and situations/protocols in which failures may occur and yet the (original) specification is still satisfied. 

It is known that satisfiability and model checking of RoCTL* are decidable, and that RoCTL* is expressively equivalent to CTL*, but non-elementarily more succinct than CTL*. The main open question (not solved in this paper) is whether RoCTL* has an elementary decision procedure. This motivates the study of fragments and logics related to RoCTL*. Indeed, one of the stated motivations is to find fragments of RoCTL* that one can prove have elementary (or efficient) decision procedures. To this end, the authors identify a CTL-like fragment called State-RoCTL* that has the same complexity (of satisfiability and model checking) as CTL. Another related logic is the bundled-variant RoBCTL*. This logic has the same syntax as RoCTL* but the semantics are different: paths are restricted to a given set of paths (that are suffix and fusion closed). The authors prove that satisfiability is decidable using an extension Reynolds' tableaux procedure for CTL*. They also identify syntactic fragments of RoBCTL* for which satisfiability is elementary.  Finally, another CTL-like fragment Pair-RoCTL* is considered, which turns out to be much more like CTL* than CTL.

--------------
Evaluation
--------------

The paper is within the scope of I&C and readers of this journal will find it relevant.

The results seem novel, and the main results were presented in conferences (TIME and JELIA) and one of the authors' PhD Thesis.

The paper seems to have been hastily put together and requires much work to bring it into publishable form. In particular (see comments to the authors, below)
- some notations can be improved to help the reader quickly grasp the nature of the objects,
- some important definitions are missing,
- the main objects, including RoCTL*, should be better motivated,
- the contributions are not spelled out clearly enough,
- some sections/paragraphs appear out of the blue which makes them hard to follow,
- some of the proofs require cleaning and more care, and all of the main proofs require carefully worded proof ideas to make them more digestible.

Due to the poor organisation of the proofs, I was not able to verify all of them line by line.
Having said that, the proof techniques all have to deal with the operator R which has the unusual
property that R\phi is a path-formula, while R is a path quantifier. This leads, e.g., to an interesting variation
of the tableaux proof for CTL* of [8].

I suggest acceptance, subject to major revisions.

---------------------------------------------
General comments to the authors
---------------------------------------------

-- It would help the reader if the examples (of formulas, as well as the intended scenarios where the logics might be applied) were more fleshed out.

In particular, you should clearly explain (or give examples to illustrate) what you mean by "error" and "failure"? Are these the same notions? I suppose so, although "failure" suggests that system crashes (rather than, e.g., some sensor giving the incorrect reading, or some process failing to make an action in time).

Also, it seems you intend that R quantifies over paths which are deviations of the original path, even if no error was introduced, and which are error free from the point of deviation. It is not clear why this is a natural definition. This definition should be justified (by examples, by clearer explanations, or by citations).

Also, I think there should be a good discussion about what you mean by "Robust System". E.g., you say on page 5 that a robust systems often has an implicit fairness constraint, and then give an example. The paper would be greatly enhanced if this was part of a deeper discussion about the types of systems to which these logics are targeted.

-- Please discuss the relationship between your work and related works more fully.
E.g.,
- You suggest that in previous work on this logic [1,5,etc], it is shown that RoCTL* is expressively equivalent to CTL* (and in fact a conservative extension of CTL*). It is worth pointing out what this means exactly. In particular, these logics are expressively equivalent over which set of models?
- The paper Faella, Napoli, Parente, 2010 "Graded ATL" deals with counting paths in a reactive setting, and the paper Aminof, Murano, Rubin, 2014: " Satisfiability and Model Checking of CTL* with Graded Path Modalities" deals with path quantifiers that can express certain forms of robustness that can not be expressed in CTL* (see also the references in this paper).
- You provide a tableau proof following Reynolds. Since the automata-theoretic approach to temporal-logics is well-established, you might discuss why you chose a tableau proof. Are there difficulties giving an automata-theoretic proof?

-- Some notations should be improved. For instance, delta^0, \delta^+, \delta^\omega also depend on $B$, and this should be made explicit (at least in the definitions). Other examples of poor notation are RoCTL*^S and State-RoCTL* --- please choose one.

-- There are many statements in the paper of the form "logic L is expressively equivalent to logic Q" or "logic L is an extension of logic Q". The problem is that the logics L and Q may be over different classes of models. E.g., CTL is over kripke-structures while RoCTL^S is over ROCTL^S structures. Thus you should clearly explain what you mean by "expressively equivalent" and "an extension of".

-- It seems that RoBCTL* is a semantic sublogic of RoCTL*. This should be stressed. What is the relationship between these logics wrt satisfiability? are they expressively equivalent?

Also, you should discuss the model-checking problem for RoBCTL* or explain why it was omitted. Does it make sense to talk about finite (or finitely-presentable) RoBCTL*-structures?

-- Please provide a table summarising the known results and your contributions. This makes it much easier for readers to grasp your contributions. An alternative is to add a bold subheading at the end of the introduction called "Our contributions" (i.e., before par 4 on page 4) and to make that paragraph much more precise (e.g., replace "at least as hard to reason about" by what you actually prove). Also, the relationship between the present work and the logics with v subscripted (e.g., RoCTL*_v) should be made more explicit, and mentioned in this summary.

-- The motivation for bundled logic (pages 4 and 5) could be better structured. E.g., you suggest that one reason for studying them is that it is easier to find Tableau proofs. Ok, but what are the advantages of Tableau proofs over, e.g., automata-theoretic proofs? Also, the last three paragraphs of that section (i.e., from "In section 5" to "will hold.") do not discuss the motivation for bundled logics, but rather they discuss how the tableau construction of the present paper differs from that in Reynolds' paper. This discussion should be labeled as such, and perhaps moved to a more appropriate place (perhaps in the same section as the Tableau proof). Also, since tableau's are an important part of this paper, it would be nice to have a gentler introduction to the proof, i.e., please give the general idea of the tableau (what is its shape, how is it labelled, when is it successful, etc.), and also, please give an example of a satisfiable formula and its tableau. Also, please give some intuitions/explanations/justifications for the definition of a bundle, i.e., why fusion- and suffix-closed are assumed.

----------------------------------------------
Detailed comments to the authors.
----------------------------------------------

Please stress in the preliminaries that indexing of paths starts at 0, i.e., w_0, w_1, \dots (instead of w_1, w_2, \dots).
Page 2:

- You write \box for always and then F for sometimes. Is there a good reason to mix these notations?

- It would be useful to the reader to say that more examples appear in Section 4.

- I would suggest adding an example scenario. In particular, what is "failure" intended to mean? (see comment about page 6 below).

- par 4: you state that full RoCTL* is decidable but, a) you have not described what full means, b) please be explicit if you mean that satisfiability is decidable or model-checking is decidable. Moreover, it is helpful to the reader to say a bit more about these translations, e.g., what do they preserve (truth? satisfiability?).

- par -1: the phrase "limit closure is (not) valid in a logic" is hard to understand. Can you rephrase it? What is "limit closure" a property of? (the set of runs that are considered by path quantifiers?)

Also, it would be helpful to state here that RoBCTL* is a semantic sublogic.

Also, please formally define "limit closure".

Page 3: "need to be allowed" --> "are allowed".
"subset of those of RoCTL*" ---> "subset of those allowed in RoCTL*"
"expressive fairness" --> "express fairness"

The sentence "The obvious way ..." must be rewritten. What is this way? What is the contradiction?

Also, you seem to imply that bundled logics can easily handle probabilistic reasoning. If so, this is a point worth stressing!

Definition 6:
-- You write "w in B" (twice). At first I thought you meant that $w \in B$ (which would have been a typo). Now I see that you mean that the full path is in B. Please rewrite to make this clear.

On pages 2 and 3 you refer to logics that are "amenable to automated reasoning" and "a little closer to being usable". Please be explicit: will the reader see decision procedures with (relatively) low complexity? Or will the reader see other arguments hat these logics are usable (e.g., decision procedures that are easy to implement).

Page 3:
par -2: You state that CTL is frequently used. Please be explicit. Used in tools? in papers about verification?

Satisfiability of CTL is EXPTIME-COMPLETE (not just EXPTIME).

You write "model checking CTL* is singly exponential in the length of the formula". What about the size of the Kripke structure?

par -1:why do you not call Pair-RoCTL simply RoCTL?

Page 4: par 1: The phrase "CTL model checker of [15]" sounds like it refers to a tool that does model checking, rather than an algorithm.

par 2: "not expressively equivalent" --> "not truth preserving" (?)

par 3: "With current technology State-RoCTL is tractable for larger problems than CTL*" does not make sense to me. Please rewrite/rephrase/be more explicit. What does "larger problems" mean? Larger in size? Larger in scope? Larger in quantity?

par -2: It would not hurt to remind the reader what "bundled variant" means, and what "limit closure" refers to.

Page 6:
The sentence "Informally it may be possible to enter a state labelled with v, but it is forbidden to do so; entering such a state will be considered a failure." needs fleshing out, since it is confusing as it is written. In what sense is it forbidden to enter a state labeled v? What forbids this? Also, what is "failure" supposed to mean here? Does it mean that the system crashes? or that some sensor gives the incorrect reading but the system still runs?

Page 7:
-- line -2: please say how sigma is quantified.

-- Definition 7: please stress that if pi is a deviation of sigma then pi has only finitely many failures.

Page 7 and 8: You write that you define RoCTL* and, in parenthesis that you define RoBCTL*, but then give just a single definition. What then is the definition of RoBCTL*? I assume you mean that the syntax is the same but the semantic differs. If this is the case, please say so here.

Page 8: Please rephrase the definition/description of RoBCTL*_v.  I understand it to mean that this logic does allow formulas to explicitly contain v. Also, what is the relationship between the logics in [21] and RoBCTL*_v? Also, how is v useful/used if the logic can't talk about it?

[Style] It seems you should decouple this comment about "v" from the last sentence, i.e., "The \neg, \wedge, ... from CTL" otherwise one might think (as I did) that this last sentence is specific to RoBCTL*_v.

Page 8:
-- Definition of Syntax. Why is (\phi \wedge \psi) not a state formula?
-- The style of the semantics are a little unusual. Is there a good reason not to mimic the style of the usual definition of CTL*, i.e., define state formulas \phi and path formulas \psi, and the define M,w \models \phi and define M,\pi \models \psi?

-- Please stress that, unlike O\phi and A\phi, the formula R\phi is a path formula (not a state formula).
The difficulty is one of notation: since \A and \O and \R all use the same font, it is natural for the reader to assume that they are the same types of objects, i.e., path quantifiers \X such that \X \phi is a state formula.

Definition 9: I think you meant to write \phi instead of \tau(\phi) in the second line of the dfn.

Page 10: Lemma 13 has a typo. I guess one of the RoBCTL*s should be RoCTL*.

-- Definition 14: This definition could be tightened a bit, namely,a) "the representation of", b) you give three sentences describing three overloadings of the notation |x| (please make this clearer).

-- if it is not possible to define State-RoCTL* before using it, at least give an informal description here.

-- what does "RoCTL* model" refer to? a kripke structure?

-- Example 15, item 2: "was empty" --> "is empty". In the description you imply that a failure refers to forgetting to fill the bowl. In the formulas there is no mention of this. What do errors refer to then?     What can be said about the set of formulas 1 through 5?

- In both the examples I feel that it would be clearer if the logics explicitly expressed something about $v$. Otherwise, you should give a model M of the formulas that has $v$ on some of its states.

Page 11, dfn 17: why are the subscripts used here?

dfn 18: why is the enumeration needed here? you can define \xi without it.

dfn 19: why do you use the notation $O$ for next as well as in $O^-1$ and $O^*$? What is the intuitive meaning of $O^-1$ for each of the more complicated formulas in the definition (i.e. Until and \R). What is the relationship between O^-1 and the past operator "Yesterday"?

Pages 12,13: You use * in two seemingly different ways. One in S*T and the other in O*. This would not be a problem except that the paragraph after dfn 23 seems to mix them up.

Page 13: dfn 22: please explain why you use $O$ here.

Page 14: It would be easier to follow if Lemma 28 were placed closer to definition 23.
Also, what does (\dots) inside the proof refer to?

Page 16:

line 1: rephrase. perhaps, replace the first occurrence of "describes" by "relates" and remove "might".

I don't understand the relevance/point of the par after dfn 31.

 Section 5.1. You talk about the tableau, but it has not yet been formally defined.


Page 17: You refer to a tableau as being "accepted", but this has not yet been formally defined.
In dfn 33 you use the word "succeeds", although i gather this means the same thing as "accepted".

Page 18: Lemma 35. Extra space before bold C in proof.

Page 19: Please formalise the hypothesis of Cor 40.

Page 20: That there are any "Real world uses" requires some justification.

Section 5.3: RoBCTL*-TAB is not defined. Also, please state the first sentence as a proposition or lemma, or simply say that the rest of the subsection will prove this fact.

Please give an intuition for the definition of thread, esp. item 2.

Page 21, lemma 44. missing period.

Page 23, lemma 47: you have not defined what it means for a tableau to halt.
Also, why is there a v in RoBCTL_v here?

Page 25:
Section 6.1: Why do you introduce yet another notation for pair-RoCTL?

Remove "like" from "like in the sense".

par -1: The paragraph starting "We note that the translation..." needs rewriting.  First, what sort of translation? (cf dfn 9).

Second, I couldn't get the point of the paragraph. A translation from LTL to RoCTL^P would not be much simpler than one from CTL*? I suppose it depends on what type of translation.

Page 26:
[[Tim suggests...

What does it mean for a "subset of states to form a CTL model"?

Page 34: section 7.1. It seems you mean to join pars 1 and 2.

par 2: You write that "\beta does not occur on \pi_j for j \leq i". However I do not understand the reasoning.

Page 35:
Definition 66: Please remove the ambiguity formed by having "(or \reverseR)" in parenthesis.
In particular, is \phi < \psi if phi and psi have the same number of \reverseR and |phi| < |\psi| but \psi has less R operators than phi?

Page 36, lemma 68: The sentence starting "Hence there exists an integer $i$..." seems to be missing a case, i.e., \sigma_j \not \models \beta for all j.

Also a little later you say that if \sigma \models \alpha \until \beta and if \sigma_i \not \models \beta then \simga_i \models \alpha. However this reasoning is not correct unless i is the smallest integer k such that \sigma_k \not \models \beta.


Page 39: Lemma 69: you forgot to say that \psi is a state-formula.

Page 42:
"I think you need a related work section before this. I think you should at least compare your work with other logics for robustness, perhaps other tableau for branching-time logics. There might be other related work you could mention also."... I agree ;);)

Again, limit-closed is used and not defined earlier.

"via reductions into" --> "by reducing to"

"This tableau"... Which tableau?

"We have shown that every property that can be expressed in CTL* can be expressed in Pair-RoCTL, with a minor translation on the structures." Please rewrite more clearly/be more explicit. What type of translation is exhibited?

What does it mean for CTL* to be "allowed to access the special violation atom"?

Par -2 talks about Pair-RoCTL. But then at the last sentence it suddenly talks about State-RoCTL. This is a bit jarring. Perhaps rewrite to make the connections clearer.

Par -1: You call the translation "efficient" and then "linear". Is this on purpose?

What "trivial modifications"?


C4568-Revision2.txt

The paper investigates sublogics of RoCTL*, a flavor of deontic logic used to express robustness in addition to deontic operators. In particular, the authors provide a tableau for RoBCTL*, investigating its complexity, and characterizations of Pair-RoCTL (a CTL-like restriction) and State-SoCTL*.
The topic is relevant and has a number of practical applications. However, the current version of the paper requires major corrections before it can be accepted for publication. In particular, in addition to the detailed comments listed below:

	•	I think that the paper could benefit from a running example, or at least a section with a concrete example of how specification patterns in the various sublogics could be employed to characterize properties of systems. Some examples appear in the paper, but they are currently spread in different sections.
	•	Partially related to the previous point: the authors should clarify the difference with their previous work. Again, some hints are provided (for instance, page 24: “Case 1 and 2 below are similar to […] [8]. Case 3 is original”): I think it would be better to add a paragraph in the introduction to clarify these extensions. The running example mentioned in the previous point could be used to clarify the new contributions. 
	•	The paper needs to be proofread. Is it possible that the wrong version was submitted for revision? I found authors’ notes that should have been removed before submission, in addition to several typos and typesetting issues.

Detailed comments:
	•	In the list of authors the superscripts for affiliations appear at the end of the list of authors.
	•	Abstract: “we show that we there is a linear…” -> rephrase
	•	p.3: “bundled logics can expressive fairness” -> can express
	•	p. 4 and 5: this section is a repetition of the introduction. Some phrases are copied verbatim (e.g., “Hoverver, (almost surely) […]”)
	•	p.9: “a satisfiability preserving translation is not interesting unless it is efficient” -> clarify the notion of “efficient” (this is probably not in the sense of “computationally efficient”).
	•	p.9 and in several other places in the paper: remove the authors’ names from citations, unless they are needed. For instance, “an extension of UB logic that added an until operator Emerson and Halpern [18]” should be  “an extension of UB logic that added an until operator [18]” or “Emerson and Halpern [18] proposed an extension of UB logic etc…”. Another example on page 11: “an extension of Reynold’s Reynolds [8] tableau…"
	•	Lemma 13 on p.10: “\phi will be satisfiable in RoBCTL* iff it is satisfiable in RoBCTL*” is tautological.
	•	p.11, last line of section 4: can you clarify the formula \reflectbox{R} \diamond e \implies \diamond w? it seems to me that e could become true before w along a path satisfying this property, isn’t and until formula needed here?
	•	p.13, Definition 23: was \delta defined?
	•	Definition 26: Isn’t the function h a function of \phi as well? Shouldn’t it be h(\pi,\psi)?
	•	p.17, “we let the set S’ of colours equal C_{\phi}” -> equal to 
	•	p.20: Beginning of section 5.3, I don’t think the acronym RoBCTL*-TAB was defined. I understand what it is, but it should probably be defined.
	•	p.26: remove the note inside Definition 51.
	•	p.27: “We denote \alpha is a subformula of \beta by” -> we denote that
	•	p.30: fix right margin in second item
	•	p.31: Lemma 58, “structure structure” -> remove one copy
	•	p.42. Remove the internal note (first paragraph of conclusion). In fact, I agree with its content: you should add  a related work section. This could also address my second point in the general comments above.


