%% Preliminaries: synthesis, realisability

\section{Preliminaries} \label{sec:prelims}

An \emph{alphabet} is a finite non-empty set $X$ of symbols, e.g., $\{0,1,2\}$. Let $X^+$ (resp. $X^*$) denote the set of non-empty (resp. possibly empty) finite sequences over alphabet $X$. The main technical objects of this paper are functions of the form $X^+ \to Y$ for alphabets $X,Y$. Such functions represent strategies in game-theory and trees in automata-theory. 

Sequences are indexed starting at $0$, thus we write $x = x_0 x_1 \cdots$. 



\subsection{Linear-time Temporal Logic (\LTL)} \label{sec:prelims:LTL}

%\LTL syntax is as follows.
%\head{Syntax}
	Fix a finite non-empty set $\AP$ of atomic propositions.
	The \emph{formulas of \LTL (over $\AP$)} are generated by the following grammar:
	$\varphi \!::=\! p \!\mid\! \varphi \vee \varphi \!\mid\! \neg \varphi \!\mid\!  \nextX \! \varphi \!\mid \! \varphi \until \varphi$
	where $p \in \AP$. 
	
	Formulas are interpreted over infinite traces $\alpha \in (2^{AP})^\omega$. Define the satisfaction relation
	$\models$ as follows:
	\begin{enumerate}
	\item  $(\alpha,n) \models p$ iff $p \in \alpha_n$;
% 	\vspace{-0,35em}
	\item  $(\alpha,n) \models \varphi_1 \vee \varphi_2$ iff $(\alpha,n) \models \varphi_i$ for some $i \in \{1,2\}$;
% 	\vspace{-0,35em}
	\item 	$(\alpha,n) \models \neg \varphi$ iff it is not the case that $(\alpha,n) \models \varphi$;
% 	\vspace{-0,35em}
	\item   $(\alpha,n) \models \nextX \varphi$ iff $(\alpha,n+1) \models \varphi$;
% 	\vspace{-0,35em}
	\item  $(\alpha,n) \models \varphi_1 \until \varphi_2$ iff there exists $i \geq n$ such that $(\alpha,i) \models \varphi_2$ and for all $i \leq j < n$, $(\alpha,j) \models \varphi_1$.
	\end{enumerate}
% 	\renewcommand{\baselinestretch}{1}
	Write $\alpha \models \varphi$ if $(\alpha,0) \models \varphi$ and say that $\alpha$ \emph{satisfies} $\varphi$ and that $\alpha$ is a \emph{model} of $\varphi$.
	We use the following abbreviations, $\varphi \limp \varphi' \doteq \neg \varphi \vee \varphi'$, $\true := p \vee \neg p$, $\false \doteq \neg \true$, $\eventually \varphi \doteq \true \until \varphi$, and
	$\always \varphi \doteq \varphi \until \false$.
% 	$\varphi \releases \varphi' \doteq \neg (\neg \varphi \until \neg \varphi')$ (read ``$\varphi$ releases $\varphi'$'', with the meaning that either $\varphi'$ always holds, or if it fails then at some strictly earlier point in time $\varphi$ must have held).
	%$\varphi \weakuntil \varphi' \doteq (\varphi \until \varphi') \vee \always \varphi$.
	
%	We write $mod(\phi)$ for the words that satisfy $\phi$.


\subsection{Reactive Realizability and Synthesis} \label{sec:prelims:synthesis}

Reactive Synthesis is the problem of producing a finite-state reactive module that satisfies a given property no matter how the environment behaves. 
For the most part we follow the notation in \cite{PnRo89}.\footnote{As in the modern literature, % e.g.,\cite{KlPn10}, 
we have conveniently simplified the formulation in \cite{PnRo89} by considering the predicates for each player to be Boolean variables, rather than predicates over terms over static and dynamic variables.} The set of propositions $\AP$ is partitioned into two sets: those controllable by the agent $\apa$, and those not controllable by the agent $\ape$.
Let $\Sigma_{{\ag}} = 2^{\apa}$ and $\Sigma_{{\env}} = 2^{\ape}$ be the corresponding sets of {\em assignments}, and let $\Sigma = \Sigma_{\ag} \cup \Sigma_{\env}$.
A {\em reactive module} or \emph{agent-strategy} is a function $\sigma:(\Sigma_{\env})^+ \to \Sigma_{\ag}$. Say that $\sigma$ is {\em finite-state} if it is determined by a transducer with input alphabet $\Sigma_{\env}$ and output alphabet $\Sigma_{\ag}$.\footnote{A \emph{transducer} is a deterministic finite-state machine that is fed symbols from an input alphabet $I$, and symbol by symbol, it produces a symbol from an output alphabet $O$, and changes its internal state. A transducer determines a function $I^+ \to O$. \todo{Formalise this more?}
}
A sequence $\pi = \pi_1 \pi_2 \dots$ is {\em consistent with agent-strategy $\sigma$} if for every $k \geq 1$, 
  $\pi_{k} \cap \Sigma_{\ag} = \sigma((\pi_1 \cap \Sigma_{\env}) \cdots (\pi_k \cap \Sigma_{\env}))$.
 
% \begin{definition}[Realizable]
% A strategy $\sigma$ \emph{realizes} an \LTL formula $\varphi$, written $\sigma \sat \varphi$, if every
% $\pi$ consistent with $\sigma$ satisfies $\varphi$.  
% \end{definition}





In \LTL Reactive Synthesis the full specification is given as a single \LTL formula $\varphi$.

\begin{definition}[\LTL Realisability]
Given an \LTL-formula $\varphi$ over alphabet $\Sigma = \Sigma_{\ag} \cup \Sigma_{\env}$, decide if there exists an agent-strategy 
$\sigma$ such that every play $\pi$ consistent with $\sigma$ satisfies $\varphi$. In this case, say that $\sigma$ \emph{realises} $\varphi$, and write 
$\sigma \sat \varphi$.
\end{definition}


\begin{definition}[\LTL Synthesis]
 Assume that $\varphi$ is realisable. The synthesis problem asks to return a finite-state agent-strategy realising $\varphi$.
\end{definition}


\begin{theorem}\label{thm:classic}
\LTL realizability is $2$\exptime-complete, and synthesis can be solved in $2$\exptime. \todo{Does it make sense to talk about synthesis being complete?}
\end{theorem}

{\bf Notation.} 
From now on we drop the adjective ``Reactive`` and just say, e.g., ``\LTL Synthesis'' instead of ``\LTL Reactive Synthesis''.

% A {\em history for ${\env}$} is a sequence from  $(\Sigma_{\ag})^*$, collectively denoted $\hist_{\env}$,  
% A {\em history for ${\ag}$} is a sequence from  $(\Sigma_{\env})^+$, collectively denoted $\hist$.
% An {\em $x$-strategy} is a function $\sigma:(\Sigma_{\env})^+ \to \Sigma_x$ (for $x \in \{{\ag},{\env}\}$).
% A play $\pi = \pi_1 \pi_2 \dots$ is {\em consistent with the strategy $\sigma$} if for every $k \geq 1$, 
%   $\pi_{k} \cap \Sigma_{\ag} = \sigma((\pi_1 \cap \Sigma_{\env}) \cdots (\pi_k \cap \Sigma_{\env}))$; 
%   and a play $\pi = \pi_1 \pi_2 \dots$ is {\em consistent with an {\env}-strategy $\sigma$} if for every $k \geq 0$, 
%   $\pi_{k+1} \cap \Sigma_{\env} = \sigma((\pi_1 \cap \Sigma_{\ag}) \cdots (\pi_k \cap \Sigma_{\ag}))$.
% For an $x$-strategy $\sigma$, write $\sigma \sat \varphi$ if every play consistent with $\sigma$ satisfies $\varphi$, and say that $\sigma$ realises $\phi$.
% The agent has an objective $\phi$, and because the game is zero-sum, the environment's objective is $\neg \phi$.


\subsection{Algorithm and Complexity} \label{sec:algorithm}

We now give the building-blocks that will be used in our Algorithm.%~\ref{alg:LTL-SuA}.

\begin{proposition}[From \LTL to \NBW] \label{prop:VW}
For every \LTL formula $\psi$ we can build an \NBW $N_\psi$ of size $2^{O(|\psi|)}$ that accepts the models of $\psi$~\cite{DBLP:journals/iandc/VardiW94}.  
\end{proposition}

\begin{lemma} \label{lem:existspath}
Let $\phi$ be an \LTL formula. 
There is an \NBT $T_\exists$ of size $2^{O(|\phi|)}$ that accepts all strategies $\sigma$ such that $\sigma \not \sat \neg \phi$.
\end{lemma}

\begin{proof}
We use the following fact: For every \NBW $N$ there is an \NBT $T$ of size linear in $N$ that accepts all strategies $\sigma$ such that some play consistent with $\sigma$ is labeled by an infinite word accepted by $N$. To see this, the \NBT $T$ guesses the path and runs the \NBW $N$ on that path, guessing the accepting run of $N$. That is, given $N = (Q,\iota,\delta,B)$ define $T = (Q,\iota',\delta',B)$ by replacing every formula $\bigvee_i q_i$ of $N$ by $\bigvee_i \bigvee_{d \in D} (d,q_i)$.

Apply Proposition~\ref{prop:VW} to $\phi$ to build an \NBW $N_\phi$ that accepts the models of $\phi$. By the fact, build an \NBT that accepts $\sigma$ iff some play consistent with $\sigma$ satisfies $\phi$, i.e., $\sigma \not \sat \neg \phi$.
\end{proof}


We now give the dual lemma.
\begin{lemma} \label{lem:allpaths}
Let $\phi$ be an \LTL formula. 
There is an \UCT $T_\forall$ of size $2^{O(|\phi|)}$ that accepts all strategies $\sigma$ such that $\sigma \sat \phi$.
\end{lemma}

\begin{proof}
Apply Lemma~\ref{lem:existspath} to $\neg \phi$ and build an \NBT that accepts all strategies $\sigma$ such that $\sigma \not \sat \phi$. Dualise the \NBT (by Fact~\ref{fact:dual}) 
to get a \UCT that accepts the complement, i.e., all strategies $\sigma$ such that $\sigma \sat \phi$.
\end{proof}



We are ready to give an algorithm for the upper bound of Theorem~\ref{thm:synth-under-assumption}.

\begin{enumerate}
 \item Build \NBT $T_1$ by Lemma~\ref{lem:existspath} applied to $\formula{\asmp}$. 
 \item Build \UCT $T_2$ by Lemma~\ref{lem:allpaths} applied to $\formula{\asmp} \limp \formula{\goal}$.
 \item Build \ABT $T$ by Fact~\ref{fact:intersection} as the intersection of $T_1$ and $T_2$.
 \item Test the emptiness, by Fact~\ref{fact:ABT-emptiness}, of the \ABT $T$, and if non-empty return a finite-state strategy.
\end{enumerate}
  

This algorithm constructs an \ABT $T$ that accepts exactly the strategies $\sigma$ such that i) $\sigma \not \sat \neg \formula{\asmp}$ and ii) $\sigma \sat \formula{\asmp} \limp \formula{\goal}$. Indeed, the \NBT $T_1$ accepts the $\sigma$ that satisfy i) and the \UCT $T_2$ accepts the $\sigma$ satisfying ii). 
The size of $T$ is $|T_1| + |T_2|  = 2^{O(|\formula{\asmp}| + |\formula{\goal}|)}$. By Fact~\ref{fact:ABT-emptiness}, testing for $T$'s emptiness results in a total cost of $2^{2^{O(|\formula{\asmp}| + |\formula{\goal}|)}}$.





\subsection{Algorithm and Complexity}

The following is proved in \cite{DBLP:conf/ijcai/GiacomoV15}, and is the finitary version of Proposition~\ref{prop:VW}.
\begin{proposition} \label{prop:VW-finite} 
For every \LTLf formula $\phi$ there is a \NFWf $N_\phi$ of size $2^{O(|\phi|)}$ that accepts the models of $\phi$.
\end{proposition}

% \begin{proof} First put $\phi$ into negation-normal form by introducing the dual operators: $\wedge$ (the dual of $\vee$), $\releases$ (the dual of $\until$), and $\Wnext$ (the dual of $\nextX$), and then
% pushing negations to the atoms (linear time). Then form an \AFWf $A_\phi$ (linear size) by
% translating the logic of the formula into the logic of the \AFWf and using
% one-step unfoldings for the temporal operators $\until$ and $\releases$.  Then
% build an equivalent \NFWf $N_\phi$ by removing alternation using a subset
% construction~\cite{ChandraKozenStockmeyer?}.  \sr{give algorithms, or cite GdGVardi} 
% \end{proof}


We now refine Lemmas~\ref{lem:existspath} and~\ref{lem:allpaths} for finite sequences. We remark that strategies are still infinite trees, 
and thus we will use \NFT and \DFT to define sets of strategies. The first lemma is proved just as Lemma~\ref{lem:existspath} but replacing Proposition~\ref{prop:VW} by Proposition~\ref{prop:VW-finite}.

\begin{lemma} \label{lem:existspath-finite}
Let $\phi$ be an \LTLf formula. 
There is an \NFT $T_\exists$ of size $2^{O(|\phi|)}$ that accepts all strategies $\sigma$ such that $\sigma \not \sat \neg \phi$. 
\end{lemma}


% \begin{proof}
%             To see the first item, apply Proposition~\ref{prop:VW-finite} to $\phi$ to build
%             an \NFWf $N_\phi$ that accepts the models of $\phi$. By Lemma~\ref{lem:guess path},
%             build an \NFT $T_\exists$ that accepts $\sigma$ iff $\sigma \not \sat \neg \phi$. This is done
%             by guessing a finite path and a finite run of the \NFWf $N_\phi$.
%             
%             To see the second item, build the \NFWf $N_\phi$ as before, and then determinise it, i.e., build an equivalent 
%             \DFWf $D_\phi$ by removing non-determinism using the classic subset construction~\cite{Rabin-Scott}. Note that the size
%             of $D_\phi$ is exponential in the size of $N_\phi$.
%             As in the proof of Lemma~\ref{lem:guess path}, build a \DFT $T_\forall$ that runs the \DFWf $D_\phi$ on all paths of the input tree $t$. 
% \end{proof}

The second lemma is similar to Lemma~\ref{lem:allpaths} except that we determinise the formula $\varphi$ (paying the extra exponent now, rather than later).
\begin{lemma} \label{lem:allpaths-finite}
Let $\phi$ be an \LTLf formula. There is an \DFT $T_\forall$ of size $2^{2^{O(|\phi|)}}$ that accepts all strategies $\sigma$ such that 
$\sigma \sat \phi$. Note that $T_\forall$ is deterministic.
\end{lemma}

\subsection{Algorithm and Complexity} \label{sec:alg:finite}

Here is the algorithm for the upper bound in Theorem~\ref{thm:synth-under-assumption:finite}.

\begin{enumerate}
\item Apply Lemma~\ref{lem:existspath-finite} to formula $\formula{\asmp}$ to get \NFT $T_1$.
\item Apply Lemma~\ref{lem:allpaths-finite} to formula $\formula{\asmp} \limp \formula{\goal}$ to get \DFT $T_2$.
\item Apply Fact~\ref{fact:nft-intersection} to get an \NFT $T$ whose language is the intersection of the languages of $T_1$ and $T_2$.
\item Use Fact~\ref{fact:nft-emptiness} to test the emptiness of the \NFT $T$, and if non-empty, return a regular tree which encodes the desired finite-state ${\ag}$-strategy.
\end{enumerate}


The size of $T$ is $|T_1| \times |T_2|$, and emptiness of $T$ is linear in $|T|$; thus the total cost of this algorithm is 
$2^{2^{O(|\formula{\asmp}| + |\formula{\goal}|)}}$.






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% save-place: t
%%% End:


