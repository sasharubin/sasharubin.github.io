
\section{Strategy Logic with Randomised Strategies}

Sentences of \SLR are interpreted over \emph{concurrent game
structures}, just as for \ATL and \SL~\cite{AHK02,MMPV14}.
		


\begin{definition}
\label{CGS}
A \emph{concurrent game structure (CGS)} 
is a tuple $\cgs \defeq \tpl{\AP, \Ag, \Ac, \St, \init, \lab, \tr}$,
			where 
			\begin{itemize}
			\item $\AP$ is a finite set \emph{atomic propositions}, 
			\item $\Ag$ is a finite set of 			\emph{agents},
			\item $\Ac$ is a finite set of \emph{actions},
			\item $\St$ is a 	finite set of		\emph{states},
			\item $\init \in \St$ is the \emph{initial
			state},  
			\item $\lab: \St \to 2^{\AP}$ is the \emph{labeling
			function} mapping each state to the set of atomic propositions true in
			that state.
			\item Let $\Dec \!\defeq\! \Ag \!\to\! \Ac$ be the
			set of \emph{decisions}, i.e., functions describing the choice
			of an action by every agent. Then, $\tr : \Dec \!\to\! (\St
			\!\to\! \St)$, a \emph{transition function}, maps every
			decision $d \!\in\! \Dec$ to a function
			$\tr(d): \St \to \St$.
			\end{itemize}
%			 \subseteq \SttSet \!\times\! \SttSet$.
%			%representing a deterministic graph over the states.
		\end{definition}

\begin{theorem}
The model-checking problem for SLR is undecidable for randomised strategies, and ?? for randomised memoryless strategies.
\end{theorem}

		\iffalse
		
		We will usually take the set $\AgnSet$ of agents to be $\{\alpha_1, \dots,
		\alpha_n\}$. % for some $n \in \Nat$.
%
		A \emph{path (from $s$)} is a finite or infinite non-empty sequence of states $s_1
		s_2 \dots$ such that $s = s_1$ and for every $i$ there exists a decision $\delta$
		with $\trnFun(\delta)(s_i) = s_{i+1}$. The set of paths starting with $s$ is denoted
		$\PthSet(s)$.
		The set of finite paths from $s$, called the \emph{histories (from $s$)}, is denoted
		$\HstSet(s)$.
%		Moreover, $\HstSet(\sttElm) \defeq \set{ \trkElm \in \HstSet }{
%		\fst{\trkElm} = \sttElm }$ (resp., $\PthSet(\sttElm) \defeq \set{ \pthElm
%		\in \PthSet }{ \fst{\pthElm} = \sttElm }$) indicates the subsets of
%		histories (resp., paths) starting at a state $\sttElm \in
%		\SttSet$.~\footnote{By $\fst{\wElm} \defeq (\wElm)_{0}$ it is denoted the
%		\emph{first element} of a non-empty sequence $\wElm \in \Sigma^{\infty}$.}
%		
		A \emph{strategy (from $s$)} is a function $\strElm \!\in\! \StrSet(s) \!\defeq\! \HstSet(s)
		\!\to\! \ActSet$ that prescribes which action has to be performed given a
		 history.
		%
		We write $\PthSet, \HstSet, \StrSet$ for the set of all paths, histories, and strategies (no
		matter where they start).
%		The set $\StrSet(\sttElm) \defeq \HstSet(\sttElm) \to \ActSet$ denotes
%		all strategies starting from $\sttElm$.
		We use the standard notion of equality between strategies, \cite{LB08}, i.e.,
		$\strElm_1 = \strElm_2$ iff for all $\rho \in \HstSet$, $\strElm_{1}(\rho) = \strElm_{2}(\rho)$.
		This extends to equality between two $n$-tuples of strategies in the
		natural way, i.e., coordinate-wise.
		

%		We assume, \wlogx that, in each state, all agents can always
%		take an action.
	\end{subsection}
	
	\begin{subsection}{Syntax}
	
%		We describe the syntax as well as related basic concepts.
		\GSLT extends \SL\ by replacing the singleton strategy quantifiers
		$\EExs{\varElm}$ and $\AAll{\varElm}$ with the graded
		(tupled) quantifiers $\EExs{\varElm_{1},\ldots, \varElm_{n}}^{\geq g}$ and
		$\AAll{\varElm_{1},\ldots, \varElm_{n}}^{< g}$, respectively, where each
		$\varElm_{i}$ belongs to a countable set of variables $\VarSet$
		and $g \in \SetN \cup \{\aleph_0, \aleph_1, 2^{\aleph_0}\}$ is called the \emph{grade} of the quantifier.
		Intuitively, these are read as ``there
		exist at least $g$ tuples of strategies $(\varElm_{1},\ldots,
		\varElm_{n})$'' and ``all but less than $g$ many tuples of strategies'',
		respectively. The syntax $(\alpha, \varElm)$ denotes a \emph{binding} of the agent $\alpha$ to the strategy $\varElm$.
		%The syntax of \GSLT is:
		
		\begin{definition}
			\GSLT \emph{formulas} are built inductively by means of the following
			grammar, where $\apElm \in \APSet$, $\alpha \in \AgnSet$,
			$\varElm,\varElm_1, \dots \varElm_n \in \VarSet$ such that $x_i \neq x_j$ for $i \neq j$,
			and $n \in \SetN$, and $g \in \SetN \cup \{\aleph_0, \aleph_1, 2^{\aleph_0}\}$:
      %\vspace{0.5em}
			\begin{center}
				$\varphi \seteq
				\apElm \mid
				\neg \varphi
				\mid \varphi \vee \varphi
				\mid \nextt \varphi
				\mid \varphi \until \varphi
				\mid \EExs{\varElm_{1},\ldots, \varElm_{n}}^{\geq g} \varphi
				\mid (\alpha, \varElm) \varphi$.
			\end{center}
      %\vspace{0.5em}
		\end{definition}
		
	
	
		{\bf Notation.} Whenever we write $\EExs{\varElm_{1},\ldots, \varElm_{n}}^{\geq g}$
		we mean that $\varElm_i \neq \varElm_j$ for $i \neq j$, i.e., the variables in a tuple are distinct. Shorthands are derived as usual.
		Specifically, $\true \defeq p \vee \neg p$, $\false \defeq \neg \true$,
$\eventually \varphi \defeq \true \until \varphi$, and
		$\always \varphi \defeq
		\neg \eventually \neg \varphi$. % $\varphi \R \psi \defeq \neg (\neg \varphi \until \neg		\psi)$.
		Also, we have that $\AAll{\varElm_{1},\ldots, \varElm_{n}}^{< g}
		\varphi \defeq \neg \EExs{\varElm_{1},\ldots, \varElm_{n}}^{\geq g}
		\neg\varphi$.
		
		In order to define the semantics, we first define the concept of
		\emph{free placeholders} in a formula, which refer to agents and variables.
		Intuitively, an agent or variable is free in $\varphi$ if it does
		not have a strategy associated with it (either by quantification or binding) but one is required in order
		to ascertain if $\varphi$ is true or not.
%		
%		 The definition of the
%		set of free agents and variables of a \GSLT\
%		formula $\varphi$, written $\freeFun{\varphi}$, mimics that one for \SL~\cite{MMPV14}.
%		%
%		 Additionally, we
%		have that:
%		$\freeFun{\EExs{\varElm_{1},\ldots, \varElm_{n}}^{\geq g} \varphi}
%					\defeq \freeFun{\varphi} \setminus \{ \varElm_{1},\ldots,
%					\varElm_{n} \}$. 
					%
							%	\label{def:sl(freeagvar)}
								%The set $\freeFun{\varphi} \subseteq \AgnSet \cup \VarSet$
								The set of \emph{free agents} and \emph{free variables} of a \GSLT\
								formula $\varphi$ is given by
								the function $\mthfun{free} : \GSLT \to \pow{\AgnSet \cup \VarSet}$
								defined as follows:
								\begin{itemize}
									%\setlength{\itemsep}{2pt}
									\item
										$\mthfun{free}(\apElm) \defeq \emptyset$, where $\apElm \in \APSet$;
									\vspace{-0.35em}
									\item\label{def:sl(freeagvar:neg)}
										$\freeFun{\neg \varphi} \defeq \freeFun{\varphi}$;
									\vspace{-0.35em}
									\item\label{def:sl(freeagvar:conjdisj)}
										$\freeFun{\varphi_{1} \vee \varphi_{2}} \defeq \freeFun{\varphi_{1}}
										\cup \freeFun{\varphi_{2}}$;
									\vspace{-0.35em}
									\item\label{def:sl(freeagvar:next)}
										$\freeFun{\nextt \varphi} \defeq \AgnSet \cup \freeFun{\varphi}$;
									\vspace{-0.35em}
									\item\label{def:sl(freeagvar:untilrelease)}
										$\freeFun{\varphi_{1} \until \varphi_{2}} \defeq \AgnSet \cup
										\freeFun{\varphi_{1}} \cup \freeFun{\varphi_{2}}$;
									\vspace{-0.35em}
									\item\label{def:sl(freeagvar:qnt)}
										$\freeFun{\EExs{\varElm_{1},\ldots, \varElm_{n}}^{\geq g} \varphi}
										\defeq \freeFun{\varphi} \setminus \{ \varElm_{1},\ldots,
										\varElm_{n} \}$;
									\vspace{-0.35em}
									\item\label{def:sl(freeagvar:bndprs)}
										$\freeFun{(\alpha, \xElm) \varphi} \defeq \freeFun{\varphi}$, if $\alpha
										\not\in \freeFun{\varphi}$, where $\alpha \in \AgnSet$ and $\xElm \in
										\VarSet$;
									\vspace{-0.35em}
									\item\label{def:sl(freeagvar:bndrem)}
										$\freeFun{(\alpha, \xElm) \varphi} \defeq (\freeFun{\varphi} \setminus
										\{ \alpha \}) \cup \{ \xElm \}$, if $\alpha \in \freeFun{\varphi}$,
										where $\alpha \in \AgnSet$ and $\xElm \in \VarSet$.
								\end{itemize}
								%
								A formula $\varphi$ without free agents (resp., variables), i.e., with
								$\freeFun{\varphi} \cap \AgnSet = \emptyset$ (resp., $\freeFun{\varphi}
								\cap \VarSet = \emptyset$), is called \emph{agent-closed} (resp.,
								\emph{variable-closed}).
								If $\varphi$ is both agent- and variable-closed, it is called a
								\emph{sentence}.
					
					
											
			A formula $\varphi$ without free agents (resp., variables), i.e.,
			with $\freeFun{\varphi} \cap \AgnSet = \emptyset$ (resp.,
			$\freeFun{\varphi} \cap \VarSet = \emptyset$), is called
			\emph{agent-closed} (resp., \emph{variable-closed}).
			Also, $\varphi$ is a \emph{sentence} if it is  both agent- and
			variable-closed. 
			
		\SL\ has a few natural syntactic fragments, the most powerful of which is
		called Nested-Goal \SL.
		Similarly, we define \emph{Nested-Goal \GSLT} (abbreviated \NGGSLT), as a syntactic fragment of
		\GSLT.
%		In words, the Nested-Goal fragment encompasses formulas in a special prenex
%		normal	 form with a ``nested temporal goal structure''.
% 		For a \emph{goal} we mean a formula of the type $\bndElm \psi$, where
% 		$\bndElm$ is a binding prefix of the form $(\alpha_{1}, \xElm[1]), \ldots,
% 		(\alpha_{n}, \xElm[n])$ containing all the involved agents and $\psi$ is an
% 		agent-full formula.
		As in  \NGSL, in \NGGSLT we require that bindings and 
		quantifications appear in exhaustive blocks. I.e., whenever there is a 
quantification over a variable in a formula $\psi$ it is part of a consecutive 
sequence of quantifiers that covers all of the free variables that appear in 
$\psi$, and whenever an agent is bound to a strategy then it is part of a 
consecutive sequence of bindings of all agents to strategies. Finally, formulas 
with free agents are not allowed.
		To formalize \NGGSLT we first introduce some notions.
		A \emph{quantification prefix} over a finite set $\VSet \!\subseteq\! \VarSet$ of
		variables is a sequence $\qntElm \!\in\! \set{ \EExs{\varElm_{1},\ldots,
		\varElm_{n}}^{\geq g}, \AAll{\varElm_{1},\ldots, \varElm_{n}}^{< g} }{
		\varElm_{1},\ldots, \varElm_{n} \!\in\! \VSet \land g \!\in\! 
		\SetN \cup \{\aleph_0, \aleph_1, 2^{\aleph_0}\}
		}^{*}$ such that each $\varElm \!\in\!
		\VSet$ occurs exactly once in $\qntElm$.
		A \emph{binding prefix} is a sequence
		$\bndElm \!\in\! \set{ (\agnElm, \varElm) }{ \alpha \!\in\! \AgnSet \land
		\varElm \!\in\! \VarSet }^{*}$ such that each $\alpha \!\in\!
		\AgnSet$ occurs exactly once in $\bndElm$.
		We denote the set of binding prefixes by $\BndSet$, and the set
		of quantification prefixes over $\VSet$ by $\QntSet(\VSet)$.

%		Finally, a \emph{goal} is a \GSLT agent-closed formula of the form
%		$\bndElm \varphi$ such that $\AgnSet \subseteq \freeFun{\varphi}$ and
%		$\bndElm \in \BndSet(\VarSet)$.
		
%		The idea behind \GSLT\ Nested Goal (\NGGSLT, for short) is that, when there
%		is a quantification over a tuple of variables used in a goal, we are forced
%		to quantify over all free variables of the inner subformula containing the
%		goal itself.
%		In this way, the subformula is build only by nesting and Boolean
%		combinations of goals. \NB{I don't understand what "goal" has to do with the following dfn
%		of "Nested Goal". Suggestion: remove  "goal" and only talk about nested-goal.}
		
%		The formal definition of \NGGSLT\ follows.

		
		
		\begin{definition}
			\NGGSLT formulas are built inductively
%			from the sets of atomic
%			propositions $\APSet$, quantification prefixes $\QntSet(\VSet)$ for any
%			$\VSet \subseteq \VarSet$, and binding prefixes $\BndSet(\VarSet)$, by
			using the following grammar, with $\pElm \in \APSet$, $\qntElm \in
			 \QntSet(\VSet)$ ($\VSet \subseteq \VarSet$),
			 and $\bndElm \in
			\BndSet$:
      %\vspace{0.5em}
			\begin{center}
				$\varphi ::= \pElm \mid \neg \varphi \mid
				\varphi \vee \varphi \mid \nextt \varphi \mid \varphi \until \varphi \mid
				 \qntElm \varphi \mid \bndElm \varphi$,
			\end{center}
	%
      %\vspace{0.5em}
			where in the rule $\qntElm \varphi$ we require that $\varphi$
			is agent-closed and $\qntElm \in \QntSet(\freeFun{\varphi})$.
		\end{definition}
		
		
		Formulas of \NGGSLT\ can be classified according to their \emph{alternation 
		number}, i.e., the maximum number of quantifier switches in a quantification prefix. Formally:
		
		
		                \begin{definition}%[\!\GSLT\ Free Agents/Variables]
		                \label{def:sl(freeagvar)}
		                        The %$\freeFun{\varphi} \subseteq \AgnSet \cup \VarSet$
		                        \emph{alternation number} of a \NGGSLT\
		                        formula is given by:
		%                       the function $\mthfun{alt}$
		%                       defined as follows:
		                        \begin{itemize}
		                                %\setlength{\itemsep}{2pt}
		                                \item
		                                $\mthfun{alt}(\apElm) \defeq 0$, where $\apElm \in \APSet$;
		                                \vspace{-0.35em}
		                                \item
		                                $\mthfun{alt}(\mthfun{OP}\varphi) \defeq \mthfun{alt}(\varphi)$,
		                                where $\mthfun{OP} \in \{ \neg, \nextt, \bndElm \}$;
		                                \vspace{-0.35em}
		                                \item
		                                $\mthfun{alt}(\varphi_{1} \mthfun{OP} \varphi_{2}) \defeq 
		                                \mthfun{max}(\mthfun{alt}(\varphi_{1}), \mthfun{alt}(\varphi_{2}))$
		                                where $\mthfun{OP} \in \{ \vee, \until \}$;
		                                \vspace{-0.35em}
		                                \item
		                                $\mthfun{alt}(\qntElm \varphi) \defeq 
		                                \mthfun{max}(\mthfun{alt}(\varphi), \mthfun{alt}(\qntElm))$ where $\qntElm$ is a quantification prefix;
		                                \vspace{-0.35em}
		                                \item
		                                $\mthfun{alt}(\qntElm) \defeq 
		                                \sum_{i = 1}^{\card{\qntElm}-1} \mthfun{switch}(\qntElm_i,
		                                \qntElm_{i+1})$, where $\mthfun{switch}(Q,Q') = 
		                                0$ if $Q$ and $Q'$ are either both universal or both existential quantifiers, and $1$ otherwise.
		                        \end{itemize}
		                \end{definition}
		
		
		
% 		We denote by $\mthfun{alt}(\varphi)$ the alternation number of a
% 		\GSLT\ formula $\varphi$.
%		Since a variable $\varElm$ may be bound to more than one agent at the time,
%		we also need the subset $\shrFun{\varphi, \varElm}$ of $\AgnSet$
%		containing those agents for which a binding $(\agnElm, \varElm)$
%		occurs in $\varphi$.
		The \emph{quantifier rank} of $\varphi$ is the maximum nesting of 
quantifiers in $\varphi$,
		e.g., $\EExs{\varElm_{1},\ldots, \varElm_{n}}^{\geq g} (\alpha_{1},  
\varElm[1]) \ldots \allowbreak
	(\alpha_{n}, \varElm[n]) \bigwedge_{i = 1}^{n} (\EExs{\ySym} (\alpha_{i},
	\ySym) \psi_{i}) \rightarrow \psi_{i}$ has quantifier rank $2$ if each 
$\psi_i$ is quantifier free.
	%
		Moreover, a \emph{quantifier-block of $\varphi$} is a maximally-consecutive
		sequence of quantifiers in $\varphi$ of the same type (\ie, either all 
existential, or
		all universal). The \emph{quantifier-block rank of $\varphi$} is exactly 
like the quantifier rank
		except that a quantifier block of $j$ quantifiers contributes $1$ instead of 
$j$ to the count.

%\NB{Vadim: is the notion of principal needed? It is used in theorem 3.2}		
%		A \NGGSLT\ sentence $\phi$ is \emph{principal} if it is of the form $\phi =
%		\qntElm \psi$, where $\psi$ is agent-closed and $\qntElm \in
%		\QntSet(\freeFun{\psi})$.
%		By $\mthfun{psnt}(\varphi) \subseteq \mthfun{snt}(\varphi)$ we denote the
%		set of all principal subsentences of the formula $\varphi$.
%
	We conclude this subsection by introducing \emph{One-Goal \GSLT}, written \OGGSLT.
	The importance of this fragment in \SL stems from the fact that it strictly includes \ATLS\ while maintaining the same complexity for
	both the model checking and the satisfiability problems, \ie
	2\ExpTimeC~\cite{MMPV12,MMPV14}. However, it is commonly believed that Nash
	Equilibrium cannot be expressed in this fragment.
% 	\footnote{Recently in
% 	\cite{GHW15} it has been shown that in the restricted case of
% 	turned-based structures it is possible to express the existence of Nash
% 	equilibria in $m^{−}\ATLS$ \cite{MMV10a}, a (memoryfull) variant of $\ATLS$,
% 	known to be equivalent to $\ATLS$, but exponentially more succinct. As the
% 	authors in \cite{GHW15} also report, it is not clear how to extend this
% 	result to the concurrent behaviour, even in the two-player case.}.
	The definition of \OGGSLT follows.
	\begin{definition}
		\OGGSLT formulas are built inductively using the following grammar, with
		$\pElm \in \APSet$, $\qntElm \in
		\QntSet(\VSet)$ ($\VSet \subseteq \VarSet$),
		and $\bndElm \in \BndSet$:
      %\vspace{0.5em}
			\begin{center}
				$\varphi ::= \pElm \mid \neg \varphi \mid
				\varphi \vee \varphi \mid \nextt \varphi \mid \varphi \until \varphi
				\mid \qntElm \bndElm \varphi$,
			\end{center}
			%
      %\vspace{0.5em}
			where $\qntElm$ is a quantification prefix over $\freeFun{\bndElm \varphi}$.
		\end{definition}

	\end{subsection}
	

	\begin{subsection}{Semantics}

		As for \SL, the interpretation of a \GSLT formula requires a
		valuation of its free placeholders.
		
		\begin{definition}
		An \emph{assignment (from $s$)} is a function $\asgFun \! \in
		\AsgSet(s) \!\defeq \!(\VarSet \cup \AgnSet) \!\to\! \StrSet(s)$ mapping
		variables and agents to strategies.
%
		\end{definition}
				We denote by ${\asgFun}[\eElm \mapsto \strElm]$, with $\eElm \in \VarSet
				\cup \AgnSet$ and $\strElm \in \StrSet(s)$, the assignment
				that differs from $\asgFun$ only in the fact that $\eElm$ maps to $\strElm$.
				%
		Extend this definition to tuples: for $\overline{\eElm} = (e_1, \dots,
		e_n)$ with $e_i \neq e_j$ for $i \neq j$, define
		${\asgFun}[\overline{\eElm} \mapsto \overline{\strElm}]$ to be
		the assignment that differs from $\asgFun$ only in the fact that $\eElm_i$
		maps to $\strElm_i$ (for each $i$).
% 		Since assignments are total functions, each assignment from $s$ determines a unique path from $s$, called a play:
% 		\begin{definition}

		Since an assignment ensures that all free variables are associated with strategies, it induces a play.
		\begin{definition}
		For an assignment $\asgFun \in \AsgSet(\sElm)$ the \emph{$(\asgFun, \sElm)$-play}
		denotes the path $\pi \in \PthSet(s)$ such that for all $i \in \SetN$, it holds that $\pi_{i + 1} =
		\trnFun(\decFun)(\pi_{i})$, where $\decFun(\alpha) \defeq
		\asgFun(\alpha)(\pi_{\leq i})$ for $\alpha \in
		\AgnSet$. 				The function $\playFun : \AsgSet \times \SttSet \to \PthSet$, with
				$\dom{\playFun} \defeq \set{ (\asgFun, \sttElm) }{ \asgFun \in \AsgSet(\sttElm)
				}$, maps  $(\asgFun, \sttElm)$ to the $(\asgFun,
				\sttElm)$-play $\playFun(\asgFun, \sttElm) \allowbreak \in
				\PthSet(\sttElm)$.
		\end{definition}


		The notation $\pi_{\leq i}$ (resp. $\pi_{< i}$) denotes the prefix of the sequence $\pi$ of length $i$ (resp. $i-1$). Similarly, the notation
		$\pi_i$ denotes the $i$th symbol of $\pi$. Thus, 
$\playFun(\asgFun,\sttElm)_i$ is the $i$th state on the play determined by 
$\asgFun$ from $\sttElm$.

 		The following definition of $\asgFun_i$ says how to interpret an assignment $\asgFun$ starting from a point $i$ along the play, i.e.,
 		for each placeholder $e$, take the action the strategy $\asgFun(e)$ would do if it were given the prefix of the play up to $i$ followed by
 		the current history.
 		\begin{definition}
		For $\asgFun \in \AsgSet(\sElm)$ and $i \in \Nat$, writing
		$\rho \defeq \playFun(\asgFun,\sElm)_{\leq i}$ (the prefix of the play up to $i$) and $\tElm \defeq \playFun(\asgFun,\sElm)_i$ (the last state of $\rho$)
		define $\asgFun_i \in \AsgSet(\tElm)$ to be the assignment from $\tElm$ that maps
		$e \in \VarSet \cup \AgnSet$ to the strategy that maps $h \in \HstSet(\tElm)$ to the action $\asgFun(e)(\rho_{< i} \cdot h)$.
 		\end{definition}
%		Finally, for a formula $\varphi$, we say that $\asgFun$ is
%		\emph{$\varphi$-coherent} iff $\freeFun{\varphi} \subseteq
%		\dom{\asgFun}$.
		
			The semantics of \GSLT\ mimics the one for \SL as given in~\cite{MMPV14}.
      Given a $\CGS$ $\CGSName$, for all
			states $\sttElm \in \SttSet$ and assignments $\asgFun \in
			\AsgSet(s)$, the relation $\CGSName, \asgFun, \sttElm \models
			\varphi$, read \emph{$\varphi$ holds at $\sttElm$ in $\CGSName$ under $\asgFun$}, is defined inductively on the structure of $\varphi$.
			                \begin{definition}
			                        \label{}
			%                       Given a $\CGS$ $\CGSName$, a $\GSLT$ formula $\varphi$, a state
			%                       $\sttElm \in \SttSet$, $\varElm \in \VarSet$, $\argElm \in \AgnSet$,
			%                       $g, n \in \SetN$, and
			%                       an assignment $\asgFun \in \AsgSet(s)$,
			                        Fix a $\CGS$ $\CGSName$. For all states $\sttElm \in \SttSet$ and assignments $\asgFun \in \AsgSet(s)$,
			                        the relation $\CGSName, \asgFun, \sttElm \models \varphi$ is defined inductively on the structure of $\varphi$:
			                        \begin{itemize}
			                                \item
			                                        $\CGSName, \asgFun, \sttElm \models \apElm$ iff $\apElm \in
			                                        \apFun(\sttElm)$;
			                                \item
			                                        $\CGSName, \asgFun, \sttElm \models \neg \varphi$ iff
			                                        $\CGSName, \asgFun, \sttElm \not\models \varphi$;
			                                \item
			                                        $\CGSName, \asgFun, \sttElm \models \varphi_{1} \vee \varphi_{2}$ iff
			                                        $\CGSName, \asgFun, \sttElm \models \varphi_{1}$ or
			                                        $\CGSName, \asgFun, \sttElm \models \varphi_{2}$;
			                                \item
			                                        $\GName, \asgFun, \sttElm \models \nextt \varphi$ iff $\GName, \asgFun_1,
			                                        \playFun(\asgFun, \sttElm)_{1} \models \varphi$;
			                                \item
			                                        $\GName, \asgFun, \sttElm \models \varphi_{1} \until \varphi_{2}$ iff
			                                        there is an index $i \in \SetN$ such that $\GName, \asgFun_i,
			                                        \playFun(\asgFun, \sttElm)_{i} \models \varphi_{2}$ and, for all indexes $j
			                                        \in \SetN$ with $j < i$, it holds that $\GName, \asgFun_j,
			                                        \playFun(\asgFun,\sttElm)_{j} \models \varphi_{1}$;
			                                \item
			                                        $\CGSName, \asgFun, \sttElm \models (\alpha, \varElm) \varphi$ iff
			                                        $\CGSName, {\asgFun}[\alpha \mapsto \asgFun(\varElm)], \sttElm \models
			                                        \varphi$;
			                        \item 	\begin{center}
			                 			$\CGSName, \asgFun,\sttElm \!\models \!\EExs{\varElm_{1},\ldots,
			           					\varElm_{n}}^{\geq g} \varphi\!$                         					iff there exist $g$ many $n$-tuples of strategies $\overline{\strElm_{i}}$ ($0 \leq i < g$) such that:
			                            \it
			                            \- $\overline{\strElm_{i}} \neq \overline{\strElm_{j}}$ for $i \neq
		    								j$, and
			                                						
			                            \- $\CGSName, {\asgFun}[\overline{\varElm} \mapsto
    								\overline{\strElm_{i}}],
			                         \sttElm  \models \varphi$
			                         for $0\leq i < g$.
			                         \ti
			                         \end{center}
			                                		
			                               

			                        \end{itemize}
			                \end{definition}
			
			
		
			Intuitively, $\EExs{\varElm_{1},\ldots, \varElm_{n}}^{
			\geq g} \varphi\!$ expresses that the number of
			distinct tuples of strategies that satisfy $\varphi$ is at least $g$.

		As usual, if $\asgFun$ and $\asgFun'$ agree on $\freeFun{\varphi}$, then
		$\CGSName, \asgFun,\sttElm \models \varphi$ if and only if $\CGSName, \asgFun',\sttElm \models \varphi$, i.e., the
		truth of $\varphi$ does not depend on the values the assignment takes on placeholders that are not free.
		Thus, for a sentence $\varphi$, we write $\CGSName \models \varphi$ to mean
		that $\CGSName, \asgFun, \isttElm \models \varphi$ for some (equivalently, for all)
		assignments $\asgFun$, and where $\isttElm$ is the initial state of $\CGSName$.
	\end{subsection}
	
% 	\smallskip
% 
% 	\noindent {\bf Comparison with other logics.}
% 		In the following we give the main intuitions relating \allowbreak \GSLT
% 		with \SL\ and a \emph{naive} fragment of \GSLT\ in which quantifiers
% 		are over single variables (and not tuple of variables).
% 		
% %		\vspace{-0.5em}
% %		\paragraph{Comparison between \GSLT and \SL}
% 		\GSLT extends \SL by replacing universal and existential strategy
% 		quantifiers $\EExs{\varElm}$ and $\AAll{\varElm}$ with their graded versions
% 		over tuples of variables $\EExs{\varElm_{1},\ldots, \varElm_{n}}^{\geq g}$
% 		and $\AAll{\varElm_{1},\ldots, \allowbreak  \varElm_{n}}^{< g}$.
% 		Grades allow one to count, which is not possible, a priori, in \SL.
% 		On the other hand, every formula of \SL\ has an equivalent formula of \GSLT:
% 		formed by replacing every quantifier $\EExs{\varElm}$ with $\EExs{\varElm}^{\geq 1}$.
% 			
% %		\vspace{-0.5em}
% %		\paragraph{Comparison between \GSLT and \txtname{naive-}\GSL}
% 		An important power of \GSLT is that it can quantify over tuples of strategy
% 		variables.
% 		Consider the formula $\varphi = \EExs{\varElm, y}^{ \geq 2}
% 		(a, x) \allowbreak (b, y) \psi$ in \GSLT
% 		that represents the property in which there exist two tuples of strategies
% 		 that satisfy $\psi$, and compare it to the following attempt at expressing $\varphi$ only quantifying over single strategies:
% 		$\varphi^{\prime} \defeq
% 		\EExs{\varElm}^{\geq 2} \EExs{y}^{ \geq 2} (a,
% 		\varElm) (b, y) \psi$.
% 		Observe that $\varphi^{\prime}$ says that there
% 		are two different strategies $\sigma_{1}$ and $\sigma_{2}$ for agent
% 		$\alpha_{1}$, and for each $\sigma_i$ there are two
% 		different strategies $\delta_1^i$ and $\delta_2^i$ for the agent $\alpha_{2}$ that satisfy $\psi$.
% 		Thus, there are four tuples of strategies that satisfy $\psi$, i.e.,
% 		$\{ \sigma_{1}, \delta_1^1 \}$,
% 		$\{ \sigma_{1}, \delta_2^1\}$,
% 		$\{ \sigma_{2}, \delta_1^2 \}$,
% 		$\{ \sigma_{2}, \delta_2^2\}$. Other attempts (such as 
% 		$\EExs{\varElm}^{\geq 2} \EExs{y}^{ \geq 1} (a,	\varElm) (b, y) \psi$), 
% also fail to capture $\varphi$ as they restrict one of the agents to a single 
% strategy.  This demonstrates the inadequacy of quantifying over single 
% strategies for counting solution concepts.
%		In \GSL the four strategies for the agent $\agnElm_{2}$ have the
%		constraints that $\sigma_{2}^{1} \neq \sigma_{2}^{2}$ and $\sigma_{2}^{3}
%		\neq \sigma_{2}^{4}$ and all tuple must satisfy $\psi$.
%		Instead, in \GSLT the constraints over the strategies for the agent
%		$\agnElm_{2}$ are that $\sigma_{2}^{1} \neq \sigma_{2}^{3}$ and
%		both tuple that contains these strategies must satisfy $\psi$,
%		either $\sigma_{2}^{1} \neq \sigma_{2}^{4}$ and both tuple that contains
%		these strategies must satisfy $\psi$,
%		either $\sigma_{2}^{2} \neq \sigma_{2}^{3}$ and
%		both tuple that contains these strategies must satisfy $\psi$,
%		either $\sigma_{2}^{2} \neq \sigma_{2}^{4}$ and  both tuple that contains
%		these strategies must satisfy $\psi$.
%		It is important to note that in \GSLT is necessary that only two tuple of
%		strategies satisfy $\psi$.
%		It easy to see that the formula $\varphi^{\prime}$ is true when all
%		four tuple of strategies satisfy $\psi$.
%		In this case if the formula $\varphi^{\prime}$ is true
%		then $\varphi$ is true, but is not true the converse.

%	\end{subsubsection}

%\input	{SubsectionI-Nash}
% 	

% End of file SectionI.tex
\fi