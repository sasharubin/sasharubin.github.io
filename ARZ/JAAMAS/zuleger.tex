


Our undecidability proof proceeds by reducing the parameterised verification problem to the halting problem of two counter machines. An \emph{input-free 2-counter machine} (2CM)~\cite{Minsky67} is a deterministic program manipulating two nonnegative integer counters using instructions that can increment a counter by $1$, decrement a counter by $1$, and check whether a counter is equal to zero. We refer to the ``line numbers'' of the program code as the ``states'' of the machine. One of these states is called the \emph{halting state}, and once it is entered the machine \emph{halts}. Observe that a 2cm has a single computation, and that if it halts then the values of both counters are bounded by some integer $n$.

The \emph{non-halting problem for 2CMs} is to decide, given a 2CM $\cm$, whether it does not halt. This problem is known to be undecidable~\cite{Minsky67}. This problem is usually a convenient choice for proving undecidability of problems concerning parameterised systems due to the simplicity of the operations of counter machines.

Let $\gclass$ be the set of all graphs that are finite lines. Formally, for every $n \in \nat$ there is a graph $L_n = (V_n,E_n,\Sigma,\lambda_n) \in \gclass$, where $\Sigma = \{l,r\}$, $v_n = [n]$, $E_n = \cup_{i < n} \{(i,i+1), (i+1,i)\}$, and the label of an edge of the form $(i,i+1)$ is $r$, and of the form $(i+1,i)$ is $l$. We now describe how, given a 2CM $\cm$, one can construct a robot ensemble $\tup{R}$ which can simulate the computation of $\cm$ on long enough lines. It is important to note that we assume a very restricted form of sensing/communication in which a robot only knows which of the other robots are on the same vertex as itself.

The basic encoding uses three robots -- a zero marking robot and two counter robots. The zero robot never moves. A value $x$ of a counter is encoded by having the corresponding counter robot occupy a node which is $2x$ steps to the right of the zero robot. Incrementing (resp. decrementing) a counter is simulated by a move of the corresponding counter robot two steps to the right (resp. left). Each of the counter robots independently simulates the control states of $\cm$. It is easy to see that a counter robot can simulate an instruction of $\cm$ that involves the counter it corresponds to, and that it can also easily update its state to the one following an increment or a decrement of the other counter. There are unfortunately two main difficulties. The first is to make sure that the two counter robots always stay synchronised in the sense that they both agree on the next instruction to simulate (i.e., we need to prevent one of them from ``running ahead''). The second difficulty concerns how a counter robot can update its state correctly when the simulated command is a test for zero of the other counter (recall that we do not allow one robot to sense if another robot is in a different node together with the zero robot). We address the first difficulty by adding additional synchronisation robots that allow a counter robot to execute an instruction only if a suitable synchronization robot is in the same vertex as it is. The   synchronization robots move in a way that ensures that the two counter robots alternate, and are thus never more than one simulated instruction of $\cm$ apart. The second difficulty is overcome by augmenting the synchronization robots with a zero-test robot that, whenever one counter is zero, moves to the position of the other counter's robot, thus signaling to it that the first counter is zero.

\begin{theorem} \label{thm:PVPundec}
For every 2CM $\cm$, there is a robot ensemble $\tup{R}$ which, for every $n \geq 5$, simulates on the line $L_n$ any prefix of the computation of $\cm$ in which the counters never exceed the value $(n-3)/2$.
\end{theorem}
\begin{proof}
The ensemble consists of the following robots:
(i) the \emph{zero robot} $\zero$, whose position marks the zero value of the counters;
(ii) the \emph{counter robots} $\counter_0$ and $\counter_1$, which encode the states and counter values of $\cm$;
(iii) the \emph{synchronization robots} $\round_0,\ldots,\round_3$ and their \emph{helper robots} $\helper_0,\ldots,\helper_3$, which are used solely to enforce a round-robin scheduling structure of the counter robots;
(iv) the \emph{zero-test robot} $\zeroTest$, which communicates to one counter robot that the other counter is zero;
(v) the \emph{boundary} robot $\boundary$ which bounds the other robots from the right -- when a synchronization robot collides with $\boundary$ it changes direction and goes back to the beginning of the line.

Consider the initial configuration $c$ where all robots are in their initial state and their positions are as follows: robots $\round_0,\ldots,\round_3$ are on node $1$, robots $\helper_0,\ldots,\helper_3$ are on node $2$, robots $\zero$, $\zeroTest$, $\counter_0, \counter_1$ are on node $3$, and $\boundary$ is on node $4$.\sr{If one allows A more complicated construction (?) }
The definition of the transitions of the robots has the important property that there is
only one possible run from configuration $c$, i.e., at each point in time exactly one robot has a transition with a test that evaluates to $\true$.

Each command of the 2CM $\cm$ is simulated by the ensemble using $4$ phases.
For every $i \in \{0,1,2,3\}$, phase $i$ has the following internal stages: (1) the synchronizing robots and their helpers organize themselves in a way that signals to robot $\round_i$ to start moving to the right $(\star)$; (2) robot $\round_i$ moves to the right until it collides with robot $\counter_j$ (where $j = i \bmod 2$); (3) robot $\counter_j$ simulates the relevant half of the current instruction of $\cm$ as described below $(\dagger)$; (4) robot $\round_i$ moves to the right until it collides with the boundary robot $\boundary$; (5) robot $\round_i$ moves to the left until it reaches node $1$ (detected by colliding with $\helper_i$). In case the other counter (i.e., counter $1-j$) is zero, stage (2) of phases one and two are modified as follows: when robot $\round_i$ enters node $3$ from the left it collides with both $\zero, \counter_{1-j}$ and $\zeroTest$; at this point both $\zeroTest$ and $\round_1$ will start moving right together, where $\zeroTest$ always goes first, and then $\round_i$ follows in lock-step; at the end of stage $2$ both $\zeroTest$ and $\round_i$ collide with $\counter_j$, thus allowing the latter to know that counter $1-j$ is zero. Finally, in order to keep the robot $\boundary$ always to the right of the other robots at the beginning of every phase we modify stage (4) such that when $\round_i$ collides with $\boundary$ and it finds $\counter_j$ also there (this may occur if the latter moved right in the previous stage), then it is not allowed to move until $\boundary$ moves out of that node (which it does by stepping to the right).


The operation performed by $\counter_j$ in stage (3) of each phase is as follows $(\dagger)$:
Recall that a value of a counter is half the distance between the corresponding counter robot and the $\zero$ robot.
In the first phase $\counter_0$ simulates the first half the instruction, in phase two $\counter_1$ simulates the first half of the same instruction, in phase three $\counter_0$ simulates the second half of the instruction and in phase four $\counter_0$ does so. For example, if the instruction is ``increment counter $0$'' then in phase $1$ robot $\counter_0$ moves right one step (and updates its simulated state of $\cm$ to be the next instruction of $\cm$), in phase $2$ robot $\counter_1$ moves right one step (and updates its simulated state of $\cm$), in phase $3$ robot $\counter_0$ moves again one step to the right (thus encoding an incremented counter), and in phase $4$ robot $\counter_0$ moves left one step (thus, returning to its previously encoded value). Simulating the other three increment and decrement commands is done similarly. The only other command we need to simulate is of the form ''if counter $i$ is zero goto state $p$ else goto state $q$''. Since this command does not change the value of any counter it is simulated by each counter robot going right in the first half and left on the second half. The internal state of $\cm$ is updated to $p$ or $q$ depending on the value of the counter. When it simulates the first half of the instruction, robot $\counter_j$ knows that its counter is zero if it is in the same node as $\zero$, and that the other counter is zero if it is in the same node as $\zeroTest$.

We now turn to the role of the helper robots and the reason for stage (1) in
each phase ($\star$). It is not hard to see that without the helper robots and stage (1)
at the beginning of each phase all the synchronization robots are in node $1$.
Thus, due to this symmetry, there is no way for them to know which phase should
start next (i.e., which of them should start moving to the right towards the counter robots). 
The helper robots allow us to break this symmetry, and their
distribution of the helper and synchronisation robots between nodes $1$ and $2$ serves to encode the current phase.

In the full version of this paper we give more details that explain exactly how stage $1$ of each phase is executed (and why it is necessary), and why at each point in time the only possible move of any robot in the ensemble is to follow the stages of each phase as outlined above. We also explain why each simulated instruction is done in four phases.
\end{proof}


\sr{The above proofs can be strengthened such that robots can be placed arbitrarily on the line in the beginning.}
\sr{TODO: Do we need this strengthening?
TODO: can't we simply put this initial condition into the task? i.e. say if we start as required then we explore, or some such thing? (Sasha: how does one express the initial condition using only collision detection?)}

\sr{sasha todo:replace following pars by statement, not cor environment}
From the previous theorem we can easily deduce that the PVP for termination tasks (``no robot ever enters a halting state'') is undecidable. We indicate that other interesting tasks are also undecidable:

\begin{corollary}
Let $\T$ be the task ``there is some ordering such that some robot explores'' \footnote{In \MRTL\ this task is written $(\forall \tup{x}) (\exists \tup{y}) (\exists \tup{X}) Reach_{\exists}(\tup{X},\tup{x},\tup{y}) \wedge (\vee_i X_i = V)$.}, let $\gclass$ be the class of line graphs, let $\rclass$ be the set of all $13$-ensemble robots whose only testing ability is collision-tests, and let $\Omega$ be the set of all orderings. Then $\PVP_{\T,\Omega}(\gclass,\rclass)$ is undecidable.
\end{corollary}

\begin{proof}
The proof of Theorem \ref{thm:PVPundec} works equally well for a counter machine with more than two counters. So, apply it to an ammended CM in which there is an extra counter $C_2$ that is incremented every second step, and never tested. This counter-robot always moves to the right (whenever it is scheduled). The ammended CM has no halting computation if and only if the third counter-robot visits every node of every line. \qed
\end{proof}

We note that the construction of the theorem also works for the synchronous model (i.e., there is no scheduling and at every time step all robots can act) because in the construction there is only one possible schedule, so we can consider this as if all robots were synchronously scheduled to move and only one did not remain idle. This strengthens the previously known fact that PVP is undecidable for synchronous robots on a line with remote testing abilities (e.g., robot $l$ can test if ``robots $i$ and $j$ are in the same node'').

